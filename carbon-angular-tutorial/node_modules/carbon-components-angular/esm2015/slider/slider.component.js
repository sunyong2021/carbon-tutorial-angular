/**
 *
 * carbon-angular v0.0.0 | slider.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, HostBinding, Input, Output, EventEmitter, ViewChild, ElementRef, TemplateRef, ViewChildren, QueryList } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { EventService } from "carbon-components-angular/utils";
/**
 * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.
 *
 * [See demo](../../?path=/story/slider--advanced)
 *
 * The simplest possible slider usage looks something like:
 * ```html
 * <ibm-slider></ibm-slider>
 * ```
 *
 * That will render a slider without labels or alternative value input. Labels can be provided by
 * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied
 * for use as an alternative value field.
 *
 * ex:
 * ```html
 * <!-- full example -->
 * <ibm-slider>
 *		<span minLabel>0GB</span>
 *		<span maxLabel>100GB</span>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just an input -->
 * <ibm-slider>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just one label -->
 * <ibm-slider>
 *		<span maxLabel>Maximum</span>
 *	</ibm-slider>
 * ```
 *
 * Slider supports `NgModel` by default, as well as two way binding to the `value` input.
 *
 * <example-url>../../iframe.html?id=slider--advanced</example-url>
 */
export class Slider {
    constructor(elementRef, eventService) {
        this.elementRef = elementRef;
        this.eventService = eventService;
        /** The interval for our range */
        this.step = 1;
        /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */
        this.id = `slider-${Slider.count++}`;
        /** Value used to "multiply" the `step` when using arrow keys to select values */
        this.shiftMultiplier = 4;
        /** Set to `true` for a loading slider */
        this.skeleton = false;
        /** Set to `true` for a slider without arrow key interactions. */
        this.disableArrowKeys = false;
        /** Emits every time a new value is selected */
        this.valueChange = new EventEmitter();
        this.hostClass = true;
        this.labelId = `${this.id}-label`;
        this.bottomRangeId = `${this.id}-bottom-range`;
        this.topRangeId = `${this.id}-top-range`;
        this.fractionComplete = 0;
        this.isMouseDown = false;
        this._min = 0;
        this._max = 100;
        this._value = [this.min];
        this._previousValue = [this.min];
        this._disabled = false;
        this._focusedThumbIndex = 0;
        /** Send changes back to the model */
        this.propagateChange = (_) => { };
        /** Callback to notify the model when our input has been touched */
        this.onTouched = () => { };
    }
    /** The lower bound of our range */
    set min(v) {
        if (!v) {
            return;
        }
        this._min = v;
        // force the component to update
        this.value = this.value;
    }
    get min() {
        return this._min;
    }
    /** The upper bound of our range */
    set max(v) {
        if (!v) {
            return;
        }
        this._max = v;
        // force the component to update
        this.value = this.value;
    }
    get max() {
        return this._max;
    }
    /** Set the initial value. Available for two way binding */
    set value(v) {
        if (!v) {
            v = [this.min];
        }
        if (typeof v === "number" || typeof v === "string") {
            v = [Number(v)];
        }
        if (v[0] < this.min) {
            v[0] = this.min;
        }
        if (v[0] > this.max) {
            v[0] = this.max;
        }
        if (this.isRange()) {
            if (this._previousValue[0] !== v[0]) { // left moved
                if (v[0] > v[1] - this.step) {
                    // stop the left handle if surpassing the right one
                    v[0] = v[1] - this.step;
                }
                else if (v[0] > this.max) {
                    v[0] = this.max;
                }
                else if (v[0] < this.min) {
                    v[0] = this.min;
                }
            }
            if (this._previousValue[1] !== v[1]) { // right moved
                if (v[1] > this.max) {
                    v[1] = this.max;
                }
                else if (v[1] < this._value[0] + this.step) {
                    // stop the right handle if surpassing the left one
                    v[1] = this._value[0] + this.step;
                }
                else if (v[1] < this.min) {
                    v[1] = this.min;
                }
            }
        }
        this._previousValue = [...this._value]; // store a copy, enable detection which handle moved
        this._value = [...v]; // triggers change detection when ngModel value is an array (for range)
        if (this.isRange() && this.filledTrack) {
            this.updateTrackRangeWidth();
        }
        else if (this.filledTrack) {
            this.filledTrack.nativeElement.style.transform = `translate(0%, -50%) ${this.scaleX(this.getFractionComplete(v[0]))}`;
        }
        if (this.inputs && this.inputs.length) {
            this.inputs.forEach((input, index) => {
                input.value = this._value[index].toString();
            });
        }
        const valueToEmit = this.isRange() ? v : v[0];
        this.propagateChange(valueToEmit);
        this.valueChange.emit(valueToEmit);
    }
    get value() {
        if (this.isRange()) {
            return this._value;
        }
        return this._value[0];
    }
    /** Disables the range visually and functionally */
    set disabled(v) {
        this._disabled = v;
        // for some reason `this.input` never exists here, so we have to query for it here too
        const inputs = this.getInputs();
        if (inputs && inputs.length > 0) {
            inputs.forEach(input => input.disabled = v);
        }
    }
    get disabled() {
        return this._disabled;
    }
    ngAfterViewInit() {
        // bind mousemove and mouseup to the document so we don't have issues tracking the mouse
        this.eventService.onDocument("mousemove", this.onMouseMove.bind(this));
        this.eventService.onDocument("mouseup", this.onMouseUp.bind(this));
        // apply any values we got from before the view initialized
        this.value = this.value;
        // TODO: ontouchstart/ontouchmove/ontouchend
        // set up the optional input
        this.inputs = this.getInputs();
        if (this.inputs && this.inputs.length > 0) {
            this.inputs.forEach((input, index) => {
                input.type = "number";
                input.classList.add("bx--slider-text-input");
                input.classList.add("bx--text-input");
                input.setAttribute("aria-labelledby", `${this.bottomRangeId} ${this.topRangeId}`);
                input.value = index < this._value.length ? this._value[index].toString() : this.max.toString();
                // bind events on our optional input
                this.eventService.on(input, "change", event => this.onChange(event, index));
                if (index === 0) {
                    this.eventService.on(input, "focus", this.onFocus.bind(this));
                }
            });
        }
    }
    trackThumbsBy(index, item) {
        return index;
    }
    /** Register a change propagation function for `ControlValueAccessor` */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /** Register a callback to notify when our input has been touched */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /** Receives a value from the model */
    writeValue(v) {
        this.value = v;
    }
    /**
     * Returns the amount of "completeness" of a value as a fraction of the total track width
     */
    getFractionComplete(value) {
        if (!this.track) {
            return 0;
        }
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        return this.convertToPx(value) / trackWidth;
    }
    /** Helper function to return the CSS transform `scaleX` function */
    scaleX(complete) {
        return `scaleX(${complete})`;
    }
    /** Converts a given px value to a "real" value in our range */
    convertToValue(pxAmount) {
        // basic concept borrowed from carbon-components
        // ref: https://github.com/IBM/carbon-components/blob/43bf3abdc2f8bdaa38aa84e0f733adde1e1e8894/src/components/slider/slider.js#L147-L151
        const range = this.max - this.min;
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        const unrounded = pxAmount / trackWidth;
        const rounded = Math.round((range * unrounded) / this.step) * this.step;
        return rounded + this.min;
    }
    /** Converts a given "real" value to a px value we can update the view with */
    convertToPx(value) {
        if (!this.track) {
            return 0;
        }
        const trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        if (value >= this.max) {
            return trackWidth;
        }
        if (value <= this.min) {
            return 0;
        }
        // account for value shifting by subtracting min from value and max
        return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));
    }
    /**
     * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    incrementValue(multiplier = 1, index = 0) {
        this._value[index] = this._value[index] + (this.step * multiplier);
        this.value = this.value; // run the setter
    }
    /**
     * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    decrementValue(multiplier = 1, index = 0) {
        this._value[index] = this._value[index] - (this.step * multiplier);
        this.value = this.value; // run the setter
    }
    /**
     * Determines if the slider is in range mode.
     */
    isRange() {
        return this._value.length > 1;
    }
    /**
     * Range mode only.
     * Updates the track width to span from the low thumb to the high thumb
     */
    updateTrackRangeWidth() {
        const fraction = this.getFractionComplete(this._value[0]);
        const fraction2 = this.getFractionComplete(this._value[1]);
        this.filledTrack.nativeElement.style.transform = `translate(${fraction * 100}%, -50%) ${this.scaleX(fraction2 - fraction)}`;
    }
    /** Change handler for the optional input */
    onChange(event, index) {
        this._value[index] = Number(event.target.value);
        this.value = this.value;
    }
    /** Handles clicks on the range track, and setting the value to it's "real" equivalent */
    onClick(event) {
        if (this.disabled) {
            return;
        }
        const trackLeft = this.track.nativeElement.getBoundingClientRect().left;
        this._value[0] = this.convertToValue(event.clientX - trackLeft);
        this.value = this.value;
    }
    /** Focus handler for the optional input */
    onFocus({ target }) {
        target.select();
    }
    /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
    onMouseMove(event) {
        if (this.disabled || !this.isMouseDown) {
            return;
        }
        const track = this.track.nativeElement.getBoundingClientRect();
        let value;
        if (event.clientX - track.left <= track.width
            && event.clientX - track.left >= 0) {
            value = this.convertToValue(event.clientX - track.left);
        }
        // if the mouse is beyond the max, set the value to `max`
        if (event.clientX - track.left > track.width) {
            value = this.max;
        }
        // if the mouse is below the min, set the value to `min`
        if (event.clientX - track.left < 0) {
            value = this.min;
        }
        if (value !== undefined) {
            this._value[this._focusedThumbIndex] = value;
            this.value = this.value;
        }
    }
    /**
     * Enables the `onMouseMove` handler
     *
     * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
     */
    onMouseDown(event, index = 0) {
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this._focusedThumbIndex = index;
        this.thumbs.toArray()[index].nativeElement.focus();
        this.isMouseDown = true;
    }
    /** Disables the `onMouseMove` handler */
    onMouseUp() {
        this.isMouseDown = false;
    }
    /**
     * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
     *
     * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
     */
    onKeyDown(event, index = 0) {
        if (this.disableArrowKeys) {
            return;
        }
        const multiplier = event.shiftKey ? this.shiftMultiplier : 1;
        if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
            this.decrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
        else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
            this.incrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
    /** Get optional input fields */
    getInputs() {
        return this.elementRef.nativeElement.querySelectorAll("input:not([type=range])");
    }
}
/** Used to generate unique IDs */
Slider.count = 0;
Slider.decorators = [
    { type: Component, args: [{
                selector: "ibm-slider",
                template: `
		<ng-container *ngIf="!skeleton; else skeletonTemplate">
			<label *ngIf="label" [for]="id" [id]="labelId" class="bx--label">
				<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
				<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
			</label>
			<div class="bx--slider-container">
				<label [id]="bottomRangeId" class="bx--slider__range-label">
					<ng-content select="[minLabel]"></ng-content>
				</label>
				<div
					class="bx--slider"
					[ngClass]="{'bx--slider--disabled': disabled}">
					<ng-container *ngIf="!isRange()">
						<div
							#thumbs
							role="slider"
							[id]="id"
							[attr.aria-labelledby]="labelId"
							class="bx--slider__thumb"
							[ngStyle]="{left: getFractionComplete(value) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event)"
							(keydown)="onKeyDown($event)">
						</div>
					</ng-container>
					<ng-container *ngIf="isRange()">
						<div
							#thumbs
							*ngFor="let thumb of value; let i = index; trackBy: trackThumbsBy"
							role="slider"
							[id]="id + (i > 0 ? '-' + i : '')"
							[attr.aria-labelledby]="labelId"
							class="bx--slider__thumb"
							[ngStyle]="{left: getFractionComplete(thumb) * 100 + '%'}"
							tabindex="0"
							(mousedown)="onMouseDown($event, i)"
							(keydown)="onKeyDown($event, i)">
						</div>
					</ng-container>
					<div
						#track
						class="bx--slider__track"
						(click)="onClick($event)">
					</div>
					<div
						#filledTrack
						class="bx--slider__filled-track">
					</div>
					<input
						#range
						aria-label="slider"
						class="bx--slider__input"
						type="range"
						[step]="step"
						[min]="min"
						[max]="max"
						[value]="value.toString()">
				</div>
				<label [id]="topRangeId" class="bx--slider__range-label">
					<ng-content select="[maxLabel]"></ng-content>
				</label>
				<ng-content select="input"></ng-content>
			</div>
		</ng-container>

		<ng-template #skeletonTemplate>
			<label *ngIf="label" class="bx--label bx--skeleton"></label>
			<div class="bx--slider-container bx--skeleton">
				<span class="bx--slider__range-label"></span>
				<div class="bx--slider">
					<div class="bx--slider__thumb"></div>
					<div class="bx--slider__track"></div>
					<div class="bx--slider__filled-track"></div>
				</div>
				<span class="bx--slider__range-label"></span>
			</div>
		</ng-template>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Slider,
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
Slider.ctorParameters = () => [
    { type: ElementRef },
    { type: EventService }
];
Slider.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    value: [{ type: Input }],
    id: [{ type: Input }],
    shiftMultiplier: [{ type: Input }],
    skeleton: [{ type: Input }],
    label: [{ type: Input }],
    disableArrowKeys: [{ type: Input }],
    disabled: [{ type: Input }],
    valueChange: [{ type: Output }],
    hostClass: [{ type: HostBinding, args: ["class.bx--form-item",] }],
    thumbs: [{ type: ViewChildren, args: ["thumbs",] }],
    track: [{ type: ViewChild, args: ["track", { static: false },] }],
    filledTrack: [{ type: ViewChild, args: ["filledTrack", { static: false },] }],
    range: [{ type: ViewChild, args: ["range", { static: false },] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvc2xpZGVyLyIsInNvdXJjZXMiOlsic2xpZGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFFWixTQUFTLEVBQ1QsVUFBVSxFQUNWLFdBQVcsRUFDWCxZQUFZLEVBQ1osU0FBUyxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUNHO0FBMEZILE1BQU0sT0FBTyxNQUFNO0lBZ0psQixZQUFzQixVQUFzQixFQUFZLFlBQTBCO1FBQTVELGVBQVUsR0FBVixVQUFVLENBQVk7UUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQXZIbEYsaUNBQWlDO1FBQ3hCLFNBQUksR0FBRyxDQUFDLENBQUM7UUFzRWxCLCtIQUErSDtRQUN0SCxPQUFFLEdBQUcsVUFBVSxNQUFNLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUN6QyxpRkFBaUY7UUFDeEUsb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFDN0IseUNBQXlDO1FBQ2hDLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFHMUIsaUVBQWlFO1FBQ3hELHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQWNsQywrQ0FBK0M7UUFDckMsZ0JBQVcsR0FBb0MsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUN4QyxjQUFTLEdBQUcsSUFBSSxDQUFDO1FBUzlDLFlBQU8sR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLFFBQVEsQ0FBQztRQUM3QixrQkFBYSxHQUFHLEdBQUcsSUFBSSxDQUFD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LE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMseUJBQXlCLENBQUMsQ0FBQztJQUNsRixDQUFDOztBQTNYRCxrQ0FBa0M7QUFDbkIsWUFBSyxHQUFHLENBQUMsQ0FBQzs7WUEzRnpCLFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsWUFBWTtnQkFDdEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE4RVQ7Z0JBQ0QsU0FBUyxFQUFFO29CQUNWO3dCQUNDLE9BQU8sRUFBRSxpQkFBaUI7d0JBQzFCLFdBQVcsRUFBRSxNQUFNO3dCQUNuQixLQUFLLEVBQUUsSUFBSTtxQkFDWDtpQkFDRDthQUNEOzs7O1lBcElBLFVBQVU7WUFNRixZQUFZOzs7a0JBb0luQixLQUFLO2tCQVVMLEtBQUs7bUJBV0wsS0FBSztvQkFFTCxLQUFLO2lCQXFFTCxLQUFLOzhCQUVMLEtBQUs7dUJBRUwsS0FBSztvQkFFTCxLQUFLOytCQUVMLEtBQUs7dUJBRUwsS0FBSzswQkFhTCxNQUFNO3dCQUNOLFdBQVcsU0FBQyxxQkFBcUI7cUJBQ2pDLFlBQVksU0FBQyxRQUFRO29CQUVyQixTQUFTLFNBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTswQkFFcEMsU0FBUyxTQUFDLGFBQWEsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7b0JBRTFDLFNBQVMsU0FBQyxPQUFPLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRIb3N0QmluZGluZyxcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRBZnRlclZpZXdJbml0LFxuXHRWaWV3Q2hpbGQsXG5cdEVsZW1lbnRSZWYsXG5cdFRlbXBsYXRlUmVmLFxuXHRWaWV3Q2hpbGRyZW4sXG5cdFF1ZXJ5TGlzdFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5pbXBvcnQgeyBFdmVudFNlcnZpY2UgfSBmcm9tIFwiY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlsc1wiO1xuXG4vKipcbiAqIFVzZWQgdG8gc2VsZWN0IGZyb20gcmFuZ2VzIG9mIHZhbHVlcy4gW1NlZSBoZXJlXShodHRwczovL3d3dy5jYXJib25kZXNpZ25zeXN0ZW0uY29tL2NvbXBvbmVudHMvc2xpZGVyL3VzYWdlKSBmb3IgdXNhZ2UgaW5mb3JtYXRpb24uXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3Rvcnkvc2xpZGVyLS1hZHZhbmNlZClcbiAqXG4gKiBUaGUgc2ltcGxlc3QgcG9zc2libGUgc2xpZGVyIHVzYWdlIGxvb2tzIHNvbWV0aGluZyBsaWtlOlxuICogYGBgaHRtbFxuICogPGlibS1zbGlkZXI+PC9pYm0tc2xpZGVyPlxuICogYGBgXG4gKlxuICogVGhhdCB3aWxsIHJlbmRlciBhIHNsaWRlciB3aXRob3V0IGxhYmVscyBvciBhbHRlcm5hdGl2ZSB2YWx1ZSBpbnB1dC4gTGFiZWxzIGNhbiBiZSBwcm92aWRlZCBieVxuICogZWxlbWVudHMgd2l0aCBgW21pbkxhYmVsXWAgYW5kIGBbbWF4TGFiZWxdYCBhdHRyaWJ1dGVzLCBhbmQgYW4gYGlucHV0YCAobWF5IHVzZSB0aGUgYGlibUlucHV0YCBkaXJlY3RpdmUpIGNhbiBiZSBzdXBwbGllZFxuICogZm9yIHVzZSBhcyBhbiBhbHRlcm5hdGl2ZSB2YWx1ZSBmaWVsZC5cbiAqXG4gKiBleDpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gZnVsbCBleGFtcGxlIC0tPlxuICogPGlibS1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtaW5MYWJlbD4wR0I8L3NwYW4+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD4xMDBHQjwvc3Bhbj5cbiAqXHRcdDxpbnB1dC8+XG4gKlx0PC9pYm0tc2xpZGVyPlxuICogPCEtLSB3aXRoIGp1c3QgYW4gaW5wdXQgLS0+XG4gKiA8aWJtLXNsaWRlcj5cbiAqXHRcdDxpbnB1dC8+XG4gKlx0PC9pYm0tc2xpZGVyPlxuICogPCEtLSB3aXRoIGp1c3Qgb25lIGxhYmVsIC0tPlxuICogPGlibS1zbGlkZXI+XG4gKlx0XHQ8c3BhbiBtYXhMYWJlbD5NYXhpbXVtPC9zcGFuPlxuICpcdDwvaWJtLXNsaWRlcj5cbiAqIGBgYFxuICpcbiAqIFNsaWRlciBzdXBwb3J0cyBgTmdNb2RlbGAgYnkgZGVmYXVsdCwgYXMgd2VsbCBhcyB0d28gd2F5IGJpbmRpbmcgdG8gdGhlIGB2YWx1ZWAgaW5wdXQuXG4gKlxuICogPGV4YW1wbGUtdXJsPi4uLy4uL2lmcmFtZS5odG1sP2lkPXNsaWRlci0tYWR2YW5jZWQ8L2V4YW1wbGUtdXJsPlxuICovXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6IFwiaWJtLXNsaWRlclwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhc2tlbGV0b247IGVsc2Ugc2tlbGV0b25UZW1wbGF0ZVwiPlxuXHRcdFx0PGxhYmVsICpuZ0lmPVwibGFiZWxcIiBbZm9yXT1cImlkXCIgW2lkXT1cImxhYmVsSWRcIiBjbGFzcz1cImJ4LS1sYWJlbFwiPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUobGFiZWwpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwibGFiZWxcIj48L25nLXRlbXBsYXRlPlxuXHRcdFx0PC9sYWJlbD5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tc2xpZGVyLWNvbnRhaW5lclwiPlxuXHRcdFx0XHQ8bGFiZWwgW2lkXT1cImJvdHRvbVJhbmdlSWRcIiBjbGFzcz1cImJ4LS1zbGlkZXJfX3JhbmdlLWxhYmVsXCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRlbnQgc2VsZWN0PVwiW21pbkxhYmVsXVwiPjwvbmctY29udGVudD5cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdGNsYXNzPVwiYngtLXNsaWRlclwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwieydieC0tc2xpZGVyLS1kaXNhYmxlZCc6IGRpc2FibGVkfVwiPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNSYW5nZSgpXCI+XG5cdFx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHRcdCN0aHVtYnNcblx0XHRcdFx0XHRcdFx0cm9sZT1cInNsaWRlclwiXG5cdFx0XHRcdFx0XHRcdFtpZF09XCJpZFwiXG5cdFx0XHRcdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJsYWJlbElkXCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tc2xpZGVyX190aHVtYlwiXG5cdFx0XHRcdFx0XHRcdFtuZ1N0eWxlXT1cIntsZWZ0OiBnZXRGcmFjdGlvbkNvbXBsZXRlKHZhbHVlKSAqIDEwMCArICclJ31cIlxuXHRcdFx0XHRcdFx0XHR0YWJpbmRleD1cIjBcIlxuXHRcdFx0XHRcdFx0XHQobW91c2Vkb3duKT1cIm9uTW91c2VEb3duKCRldmVudClcIlxuXHRcdFx0XHRcdFx0XHQoa2V5ZG93bik9XCJvbktleURvd24oJGV2ZW50KVwiPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cImlzUmFuZ2UoKVwiPlxuXHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHQjdGh1bWJzXG5cdFx0XHRcdFx0XHRcdCpuZ0Zvcj1cImxldCB0aHVtYiBvZiB2YWx1ZTsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tUaHVtYnNCeVwiXG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJzbGlkZXJcIlxuXHRcdFx0XHRcdFx0XHRbaWRdPVwiaWQgKyAoaSA+IDAgPyAnLScgKyBpIDogJycpXCJcblx0XHRcdFx0XHRcdFx0W2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImxhYmVsSWRcIlxuXHRcdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1zbGlkZXJfX3RodW1iXCJcblx0XHRcdFx0XHRcdFx0W25nU3R5bGVdPVwie2xlZnQ6IGdldEZyYWN0aW9uQ29tcGxldGUodGh1bWIpICogMTAwICsgJyUnfVwiXG5cdFx0XHRcdFx0XHRcdHRhYmluZGV4PVwiMFwiXG5cdFx0XHRcdFx0XHRcdChtb3VzZWRvd24pPVwib25Nb3VzZURvd24oJGV2ZW50LCBpKVwiXG5cdFx0XHRcdFx0XHRcdChrZXlkb3duKT1cIm9uS2V5RG93bigkZXZlbnQsIGkpXCI+XG5cdFx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHQjdHJhY2tcblx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLXNsaWRlcl9fdHJhY2tcIlxuXHRcdFx0XHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdCNmaWxsZWRUcmFja1xuXHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tc2xpZGVyX19maWxsZWQtdHJhY2tcIj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdCNyYW5nZVxuXHRcdFx0XHRcdFx0YXJpYS1sYWJlbD1cInNsaWRlclwiXG5cdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1zbGlkZXJfX2lucHV0XCJcblx0XHRcdFx0XHRcdHR5cGU9XCJyYW5nZVwiXG5cdFx0XHRcdFx0XHRbc3RlcF09XCJzdGVwXCJcblx0XHRcdFx0XHRcdFttaW5dPVwibWluXCJcblx0XHRcdFx0XHRcdFttYXhdPVwibWF4XCJcblx0XHRcdFx0XHRcdFt2YWx1ZV09XCJ2YWx1ZS50b1N0cmluZygpXCI+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8bGFiZWwgW2lkXT1cInRvcFJhbmdlSWRcIiBjbGFzcz1cImJ4LS1zbGlkZXJfX3JhbmdlLWxhYmVsXCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRlbnQgc2VsZWN0PVwiW21heExhYmVsXVwiPjwvbmctY29udGVudD5cblx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0PG5nLWNvbnRlbnQgc2VsZWN0PVwiaW5wdXRcIj48L25nLWNvbnRlbnQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L25nLWNvbnRhaW5lcj5cblxuXHRcdDxuZy10ZW1wbGF0ZSAjc2tlbGV0b25UZW1wbGF0ZT5cblx0XHRcdDxsYWJlbCAqbmdJZj1cImxhYmVsXCIgY2xhc3M9XCJieC0tbGFiZWwgYngtLXNrZWxldG9uXCI+PC9sYWJlbD5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tc2xpZGVyLWNvbnRhaW5lciBieC0tc2tlbGV0b25cIj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJieC0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPjwvc3Bhbj5cblx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1zbGlkZXJcIj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNsaWRlcl9fdGh1bWJcIj48L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNsaWRlcl9fdHJhY2tcIj48L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNsaWRlcl9fZmlsbGVkLXRyYWNrXCI+PC9kaXY+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8c3BhbiBjbGFzcz1cImJ4LS1zbGlkZXJfX3JhbmdlLWxhYmVsXCI+PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9uZy10ZW1wbGF0ZT5cblx0YCxcblx0cHJvdmlkZXJzOiBbXG5cdFx0e1xuXHRcdFx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdFx0XHR1c2VFeGlzdGluZzogU2xpZGVyLFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXHQvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG5cdHByaXZhdGUgc3RhdGljIGNvdW50ID0gMDtcblxuXHQvKiogVGhlIGxvd2VyIGJvdW5kIG9mIG91ciByYW5nZSAqL1xuXHRASW5wdXQoKSBzZXQgbWluKHYpIHtcblx0XHRpZiAoIXYpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fbWluID0gdjtcblx0XHQvLyBmb3JjZSB0aGUgY29tcG9uZW50IHRvIHVwZGF0ZVxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cdGdldCBtaW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbjtcblx0fVxuXHQvKiogVGhlIHVwcGVyIGJvdW5kIG9mIG91ciByYW5nZSAqL1xuXHRASW5wdXQoKSBzZXQgbWF4KHYpIHtcblx0XHRpZiAoIXYpIHsgcmV0dXJuOyB9XG5cdFx0dGhpcy5fbWF4ID0gdjtcblx0XHQvLyBmb3JjZSB0aGUgY29tcG9uZW50IHRvIHVwZGF0ZVxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cblx0Z2V0IG1heCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF4O1xuXHR9XG5cdC8qKiBUaGUgaW50ZXJ2YWwgZm9yIG91ciByYW5nZSAqL1xuXHRASW5wdXQoKSBzdGVwID0gMTtcblx0LyoqIFNldCB0aGUgaW5pdGlhbCB2YWx1ZS4gQXZhaWxhYmxlIGZvciB0d28gd2F5IGJpbmRpbmcgKi9cblx0QElucHV0KCkgc2V0IHZhbHVlKHYpIHtcblx0XHRpZiAoIXYpIHtcblx0XHRcdHYgPSBbdGhpcy5taW5dO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgdiA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0diA9IFtOdW1iZXIodildO1xuXHRcdH1cblxuXHRcdGlmICh2WzBdIDwgdGhpcy5taW4pIHtcblx0XHRcdHZbMF0gPSB0aGlzLm1pbjtcblx0XHR9XG5cblx0XHRpZiAodlswXSA+IHRoaXMubWF4KSB7XG5cdFx0XHR2WzBdID0gdGhpcy5tYXg7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaXNSYW5nZSgpKSB7XG5cdFx0XHRpZiAodGhpcy5fcHJldmlvdXNWYWx1ZVswXSAhPT0gdlswXSkgeyAvLyBsZWZ0IG1vdmVkXG5cdFx0XHRcdGlmICh2WzBdID4gdlsxXSAtIHRoaXMuc3RlcCkge1xuXHRcdFx0XHRcdC8vIHN0b3AgdGhlIGxlZnQgaGFuZGxlIGlmIHN1cnBhc3NpbmcgdGhlIHJpZ2h0IG9uZVxuXHRcdFx0XHRcdHZbMF0gPSB2WzFdIC0gdGhpcy5zdGVwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZbMF0gPiB0aGlzLm1heCkge1xuXHRcdFx0XHRcdHZbMF0gPSB0aGlzLm1heDtcblx0XHRcdFx0fSBlbHNlIGlmICh2WzBdIDwgdGhpcy5taW4pIHtcblx0XHRcdFx0XHR2WzBdID0gdGhpcy5taW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHRoaXMuX3ByZXZpb3VzVmFsdWVbMV0gIT09IHZbMV0pIHsgLy8gcmlnaHQgbW92ZWRcblx0XHRcdFx0aWYgKHZbMV0gPiB0aGlzLm1heCkge1xuXHRcdFx0XHRcdHZbMV0gPSB0aGlzLm1heDtcblx0XHRcdFx0fSBlbHNlIGlmICh2WzFdIDwgdGhpcy5fdmFsdWVbMF0gKyB0aGlzLnN0ZXApIHtcblx0XHRcdFx0XHQvLyBzdG9wIHRoZSByaWdodCBoYW5kbGUgaWYgc3VycGFzc2luZyB0aGUgbGVmdCBvbmVcblx0XHRcdFx0XHR2WzFdID0gdGhpcy5fdmFsdWVbMF0gKyB0aGlzLnN0ZXA7XG5cdFx0XHRcdH0gZWxzZSBpZiAodlsxXSA8IHRoaXMubWluKSB7XG5cdFx0XHRcdFx0dlsxXSA9IHRoaXMubWluO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5fcHJldmlvdXNWYWx1ZSA9IFsuLi50aGlzLl92YWx1ZV07IC8vIHN0b3JlIGEgY29weSwgZW5hYmxlIGRldGVjdGlvbiB3aGljaCBoYW5kbGUgbW92ZWRcblx0XHR0aGlzLl92YWx1ZSA9IFsuLi52XTsgLy8gdHJpZ2dlcnMgY2hhbmdlIGRldGVjdGlvbiB3aGVuIG5nTW9kZWwgdmFsdWUgaXMgYW4gYXJyYXkgKGZvciByYW5nZSlcblxuXHRcdGlmICh0aGlzLmlzUmFuZ2UoKSAmJiB0aGlzLmZpbGxlZFRyYWNrKSB7XG5cdFx0XHR0aGlzLnVwZGF0ZVRyYWNrUmFuZ2VXaWR0aCgpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5maWxsZWRUcmFjaykge1xuXHRcdFx0dGhpcy5maWxsZWRUcmFjay5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoMCUsIC01MCUpICR7dGhpcy5zY2FsZVgodGhpcy5nZXRGcmFjdGlvbkNvbXBsZXRlKHZbMF0pKX1gO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlucHV0cyAmJiB0aGlzLmlucHV0cy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpbnB1dC52YWx1ZSA9IHRoaXMuX3ZhbHVlW2luZGV4XS50b1N0cmluZygpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdmFsdWVUb0VtaXQgPSB0aGlzLmlzUmFuZ2UoKSA/IHYgOiB2WzBdO1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKHZhbHVlVG9FbWl0KTtcblx0XHR0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWVUb0VtaXQpO1xuXHR9XG5cblx0Z2V0IHZhbHVlKCkge1xuXHRcdGlmICh0aGlzLmlzUmFuZ2UoKSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdmFsdWVbMF07XG5cdH1cblxuXHQvKiogQmFzZSBJRCBmb3IgdGhlIHNsaWRlci4gVGhlIG1pbiBhbmQgbWF4IGxhYmVscyBnZXQgSURzIGAke3RoaXMuaWR9LWJvdHRvbS1yYW5nZWAgYW5kIGAke3RoaXMuaWR9LXRvcC1yYW5nZWAgcmVzcGVjdGl2ZWx5ICovXG5cdEBJbnB1dCgpIGlkID0gYHNsaWRlci0ke1NsaWRlci5jb3VudCsrfWA7XG5cdC8qKiBWYWx1ZSB1c2VkIHRvIFwibXVsdGlwbHlcIiB0aGUgYHN0ZXBgIHdoZW4gdXNpbmcgYXJyb3cga2V5cyB0byBzZWxlY3QgdmFsdWVzICovXG5cdEBJbnB1dCgpIHNoaWZ0TXVsdGlwbGllciA9IDQ7XG5cdC8qKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgc2xpZGVyICovXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cdC8qKiBTZXRzIHRoZSB0ZXh0IGluc2lkZSB0aGUgYGxhYmVsYCB0YWcgKi9cblx0QElucHV0KCkgbGFiZWw6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKiBTZXQgdG8gYHRydWVgIGZvciBhIHNsaWRlciB3aXRob3V0IGFycm93IGtleSBpbnRlcmFjdGlvbnMuICovXG5cdEBJbnB1dCgpIGRpc2FibGVBcnJvd0tleXMgPSBmYWxzZTtcblx0LyoqIERpc2FibGVzIHRoZSByYW5nZSB2aXN1YWxseSBhbmQgZnVuY3Rpb25hbGx5ICovXG5cdEBJbnB1dCgpIHNldCBkaXNhYmxlZCh2KSB7XG5cdFx0dGhpcy5fZGlzYWJsZWQgPSB2O1xuXHRcdC8vIGZvciBzb21lIHJlYXNvbiBgdGhpcy5pbnB1dGAgbmV2ZXIgZXhpc3RzIGhlcmUsIHNvIHdlIGhhdmUgdG8gcXVlcnkgZm9yIGl0IGhlcmUgdG9vXG5cdFx0Y29uc3QgaW5wdXRzID0gdGhpcy5nZXRJbnB1dHMoKTtcblx0XHRpZiAoaW5wdXRzICYmIGlucHV0cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBpbnB1dC5kaXNhYmxlZCA9IHYpO1xuXHRcdH1cblx0fVxuXG5cdGdldCBkaXNhYmxlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG5cdH1cblx0LyoqIEVtaXRzIGV2ZXJ5IHRpbWUgYSBuZXcgdmFsdWUgaXMgc2VsZWN0ZWQgKi9cblx0QE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgbnVtYmVyW10+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRASG9zdEJpbmRpbmcoXCJjbGFzcy5ieC0tZm9ybS1pdGVtXCIpIGhvc3RDbGFzcyA9IHRydWU7XG5cdEBWaWV3Q2hpbGRyZW4oXCJ0aHVtYnNcIikgdGh1bWJzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcInRyYWNrXCIsIHsgc3RhdGljOiBmYWxzZSB9KSB0cmFjazogRWxlbWVudFJlZjtcblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwiZmlsbGVkVHJhY2tcIiwgeyBzdGF0aWM6IGZhbHNlIH0pIGZpbGxlZFRyYWNrOiBFbGVtZW50UmVmO1xuXHQvLyBAdHMtaWdub3JlXG5cdEBWaWV3Q2hpbGQoXCJyYW5nZVwiLCB7IHN0YXRpYzogZmFsc2UgfSkgcmFuZ2U6IEVsZW1lbnRSZWY7XG5cblx0cHVibGljIGxhYmVsSWQgPSBgJHt0aGlzLmlkfS1sYWJlbGA7XG5cdHB1YmxpYyBib3R0b21SYW5nZUlkID0gYCR7dGhpcy5pZH0tYm90dG9tLXJhbmdlYDtcblx0cHVibGljIHRvcFJhbmdlSWQgPSBgJHt0aGlzLmlkfS10b3AtcmFuZ2VgO1xuXHRwdWJsaWMgZnJhY3Rpb25Db21wbGV0ZSA9IDA7XG5cblx0cHJvdGVjdGVkIGlzTW91c2VEb3duID0gZmFsc2U7XG5cdHByb3RlY3RlZCBpbnB1dHM6IEhUTUxJbnB1dEVsZW1lbnRbXTtcblx0cHJvdGVjdGVkIF9taW4gPSAwO1xuXHRwcm90ZWN0ZWQgX21heCA9IDEwMDtcblx0cHJvdGVjdGVkIF92YWx1ZSA9IFt0aGlzLm1pbl07XG5cdHByb3RlY3RlZCBfcHJldmlvdXNWYWx1ZSA9IFt0aGlzLm1pbl07XG5cdHByb3RlY3RlZCBfZGlzYWJsZWQgPSBmYWxzZTtcblx0cHJvdGVjdGVkIF9mb2N1c2VkVGh1bWJJbmRleCA9IDA7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByb3RlY3RlZCBldmVudFNlcnZpY2U6IEV2ZW50U2VydmljZSkge31cblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0Ly8gYmluZCBtb3VzZW1vdmUgYW5kIG1vdXNldXAgdG8gdGhlIGRvY3VtZW50IHNvIHdlIGRvbid0IGhhdmUgaXNzdWVzIHRyYWNraW5nIHRoZSBtb3VzZVxuXHRcdHRoaXMuZXZlbnRTZXJ2aWNlLm9uRG9jdW1lbnQoXCJtb3VzZW1vdmVcIiwgdGhpcy5vbk1vdXNlTW92ZS5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLmV2ZW50U2VydmljZS5vbkRvY3VtZW50KFwibW91c2V1cFwiLCB0aGlzLm9uTW91c2VVcC5iaW5kKHRoaXMpKTtcblxuXHRcdC8vIGFwcGx5IGFueSB2YWx1ZXMgd2UgZ290IGZyb20gYmVmb3JlIHRoZSB2aWV3IGluaXRpYWxpemVkXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cblx0XHQvLyBUT0RPOiBvbnRvdWNoc3RhcnQvb250b3VjaG1vdmUvb250b3VjaGVuZFxuXG5cdFx0Ly8gc2V0IHVwIHRoZSBvcHRpb25hbCBpbnB1dFxuXHRcdHRoaXMuaW5wdXRzID0gdGhpcy5nZXRJbnB1dHMoKTtcblx0XHRpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5pbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG5cdFx0XHRcdGlucHV0LnR5cGUgPSBcIm51bWJlclwiO1xuXHRcdFx0XHRpbnB1dC5jbGFzc0xpc3QuYWRkKFwiYngtLXNsaWRlci10ZXh0LWlucHV0XCIpO1xuXHRcdFx0XHRpbnB1dC5jbGFzc0xpc3QuYWRkKFwiYngtLXRleHQtaW5wdXRcIik7XG5cdFx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiLCBgJHt0aGlzLmJvdHRvbVJhbmdlSWR9ICR7dGhpcy50b3BSYW5nZUlkfWApO1xuXG5cdFx0XHRcdGlucHV0LnZhbHVlID0gaW5kZXggPCB0aGlzLl92YWx1ZS5sZW5ndGggPyB0aGlzLl92YWx1ZVtpbmRleF0udG9TdHJpbmcoKSA6IHRoaXMubWF4LnRvU3RyaW5nKCk7XG5cdFx0XHRcdC8vIGJpbmQgZXZlbnRzIG9uIG91ciBvcHRpb25hbCBpbnB1dFxuXHRcdFx0XHR0aGlzLmV2ZW50U2VydmljZS5vbihpbnB1dCwgXCJjaGFuZ2VcIiwgZXZlbnQgPT4gdGhpcy5vbkNoYW5nZShldmVudCwgaW5kZXgpKTtcblxuXHRcdFx0XHRpZiAoaW5kZXggPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLmV2ZW50U2VydmljZS5vbihpbnB1dCwgXCJmb2N1c1wiLCB0aGlzLm9uRm9jdXMuYmluZCh0aGlzKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdHRyYWNrVGh1bWJzQnkoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSB7XG5cdFx0cmV0dXJuIGluZGV4O1xuXHR9XG5cblx0LyoqIFNlbmQgY2hhbmdlcyBiYWNrIHRvIHRoZSBtb2RlbCAqL1xuXHRwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XG5cblx0LyoqIFJlZ2lzdGVyIGEgY2hhbmdlIHByb3BhZ2F0aW9uIGZ1bmN0aW9uIGZvciBgQ29udHJvbFZhbHVlQWNjZXNzb3JgICovXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvKiogQ2FsbGJhY2sgdG8gbm90aWZ5IHRoZSBtb2RlbCB3aGVuIG91ciBpbnB1dCBoYXMgYmVlbiB0b3VjaGVkICovXG5cdG9uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4geyB9O1xuXG5cdC8qKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIG91ciBpbnB1dCBoYXMgYmVlbiB0b3VjaGVkICovXG5cdHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCA9IGZuO1xuXHR9XG5cblx0LyoqIFJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgbW9kZWwgKi9cblx0d3JpdGVWYWx1ZSh2OiBhbnkpIHtcblx0XHR0aGlzLnZhbHVlID0gdjtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgXCJjb21wbGV0ZW5lc3NcIiBvZiBhIHZhbHVlIGFzIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHRyYWNrIHdpZHRoXG5cdCAqL1xuXHRnZXRGcmFjdGlvbkNvbXBsZXRlKHZhbHVlOiBudW1iZXIpIHtcblx0XHRpZiAoIXRoaXMudHJhY2spIHtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVydFRvUHgodmFsdWUpIC8gdHJhY2tXaWR0aDtcblx0fVxuXG5cdC8qKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBDU1MgdHJhbnNmb3JtIGBzY2FsZVhgIGZ1bmN0aW9uICovXG5cdHNjYWxlWChjb21wbGV0ZSkge1xuXHRcdHJldHVybiBgc2NhbGVYKCR7Y29tcGxldGV9KWA7XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBnaXZlbiBweCB2YWx1ZSB0byBhIFwicmVhbFwiIHZhbHVlIGluIG91ciByYW5nZSAqL1xuXHRjb252ZXJ0VG9WYWx1ZShweEFtb3VudCkge1xuXHRcdC8vIGJhc2ljIGNvbmNlcHQgYm9ycm93ZWQgZnJvbSBjYXJib24tY29tcG9uZW50c1xuXHRcdC8vIHJlZjogaHR0cHM6Ly9naXRodWIuY29tL0lCTS9jYXJib24tY29tcG9uZW50cy9ibG9iLzQzYmYzYWJkYzJmOGJkYWEzOGFhODRlMGY3MzNhZGRlMWUxZTg4OTQvc3JjL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5qcyNMMTQ3LUwxNTFcblx0XHRjb25zdCByYW5nZSA9IHRoaXMubWF4IC0gdGhpcy5taW47XG5cdFx0Y29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRjb25zdCB1bnJvdW5kZWQgPSBweEFtb3VudCAvIHRyYWNrV2lkdGg7XG5cdFx0Y29uc3Qgcm91bmRlZCA9IE1hdGgucm91bmQoKHJhbmdlICogdW5yb3VuZGVkKSAvIHRoaXMuc3RlcCkgKiB0aGlzLnN0ZXA7XG5cdFx0cmV0dXJuIHJvdW5kZWQgKyB0aGlzLm1pbjtcblx0fVxuXG5cdC8qKiBDb252ZXJ0cyBhIGdpdmVuIFwicmVhbFwiIHZhbHVlIHRvIGEgcHggdmFsdWUgd2UgY2FuIHVwZGF0ZSB0aGUgdmlldyB3aXRoICovXG5cdGNvbnZlcnRUb1B4KHZhbHVlKSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNrKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRjb25zdCB0cmFja1dpZHRoID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdGlmICh2YWx1ZSA+PSB0aGlzLm1heCkge1xuXHRcdFx0cmV0dXJuIHRyYWNrV2lkdGg7XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlIDw9IHRoaXMubWluKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBhY2NvdW50IGZvciB2YWx1ZSBzaGlmdGluZyBieSBzdWJ0cmFjdGluZyBtaW4gZnJvbSB2YWx1ZSBhbmQgbWF4XG5cdFx0cmV0dXJuIE1hdGgucm91bmQodHJhY2tXaWR0aCAqICgodmFsdWUgLSB0aGlzLm1pbikgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmNyZW1lbnRzIHRoZSB2YWx1ZSBieSB0aGUgc3RlcCB2YWx1ZSwgb3IgdGhlIHN0ZXAgdmFsdWUgbXVsdGlwbGllZCBieSB0aGUgYG11bHRpcGxpZXJgIGFyZ3VtZW50LlxuXHQgKlxuXHQgKiBAYXJndW1lbnQgbXVsdGlwbGllciBEZWZhdWx0cyB0byBgMWAsIG11bHRpcGxpZWQgd2l0aCB0aGUgc3RlcCB2YWx1ZS5cblx0ICovXG5cdGluY3JlbWVudFZhbHVlKG11bHRpcGxpZXIgPSAxLCBpbmRleCA9IDApIHtcblx0XHR0aGlzLl92YWx1ZVtpbmRleF0gPSB0aGlzLl92YWx1ZVtpbmRleF0gKyAodGhpcy5zdGVwICogbXVsdGlwbGllcik7XG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7IC8vIHJ1biB0aGUgc2V0dGVyXG5cdH1cblxuXHQvKipcblx0ICogRGVjcmVtZW50cyB0aGUgdmFsdWUgYnkgdGhlIHN0ZXAgdmFsdWUsIG9yIHRoZSBzdGVwIHZhbHVlIG11bHRpcGxpZWQgYnkgdGhlIGBtdWx0aXBsaWVyYCBhcmd1bWVudC5cblx0ICpcblx0ICogQGFyZ3VtZW50IG11bHRpcGxpZXIgRGVmYXVsdHMgdG8gYDFgLCBtdWx0aXBsaWVkIHdpdGggdGhlIHN0ZXAgdmFsdWUuXG5cdCAqL1xuXHRkZWNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyID0gMSwgaW5kZXggPSAwKSB7XG5cdFx0dGhpcy5fdmFsdWVbaW5kZXhdID0gdGhpcy5fdmFsdWVbaW5kZXhdIC0gKHRoaXMuc3RlcCAqIG11bHRpcGxpZXIpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlOyAvLyBydW4gdGhlIHNldHRlclxuXHR9XG5cblx0LyoqXG5cdCAqIERldGVybWluZXMgaWYgdGhlIHNsaWRlciBpcyBpbiByYW5nZSBtb2RlLlxuXHQgKi9cblx0aXNSYW5nZSgpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gdGhpcy5fdmFsdWUubGVuZ3RoID4gMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSYW5nZSBtb2RlIG9ubHkuXG5cdCAqIFVwZGF0ZXMgdGhlIHRyYWNrIHdpZHRoIHRvIHNwYW4gZnJvbSB0aGUgbG93IHRodW1iIHRvIHRoZSBoaWdoIHRodW1iXG5cdCAqL1xuXHR1cGRhdGVUcmFja1JhbmdlV2lkdGgoKSB7XG5cdFx0Y29uc3QgZnJhY3Rpb24gPSB0aGlzLmdldEZyYWN0aW9uQ29tcGxldGUodGhpcy5fdmFsdWVbMF0pO1xuXHRcdGNvbnN0IGZyYWN0aW9uMiA9IHRoaXMuZ2V0RnJhY3Rpb25Db21wbGV0ZSh0aGlzLl92YWx1ZVsxXSk7XG5cdFx0dGhpcy5maWxsZWRUcmFjay5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtmcmFjdGlvbiAqIDEwMH0lLCAtNTAlKSAke3RoaXMuc2NhbGVYKGZyYWN0aW9uMiAtIGZyYWN0aW9uKX1gO1xuXHR9XG5cblx0LyoqIENoYW5nZSBoYW5kbGVyIGZvciB0aGUgb3B0aW9uYWwgaW5wdXQgKi9cblx0b25DaGFuZ2UoZXZlbnQsIGluZGV4KSB7XG5cdFx0dGhpcy5fdmFsdWVbaW5kZXhdID0gTnVtYmVyKGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdH1cblxuXHQvKiogSGFuZGxlcyBjbGlja3Mgb24gdGhlIHJhbmdlIHRyYWNrLCBhbmQgc2V0dGluZyB0aGUgdmFsdWUgdG8gaXQncyBcInJlYWxcIiBlcXVpdmFsZW50ICovXG5cdG9uQ2xpY2soZXZlbnQpIHtcblx0XHRpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblx0XHRjb25zdCB0cmFja0xlZnQgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHR0aGlzLl92YWx1ZVswXSA9IHRoaXMuY29udmVydFRvVmFsdWUoZXZlbnQuY2xpZW50WCAtIHRyYWNrTGVmdCk7XG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdH1cblxuXHQvKiogRm9jdXMgaGFuZGxlciBmb3IgdGhlIG9wdGlvbmFsIGlucHV0ICovXG5cdG9uRm9jdXMoe3RhcmdldH0pIHtcblx0XHR0YXJnZXQuc2VsZWN0KCk7XG5cdH1cblxuXHQvKiogTW91c2UgbW92ZSBoYW5kbGVyLiBSZXNwb25zaWJsZSBmb3IgdXBkYXRpbmcgdGhlIHZhbHVlIGFuZCB2aXN1YWwgc2VsZWN0aW9uIGJhc2VkIG9uIG1vdXNlIG1vdmVtZW50ICovXG5cdG9uTW91c2VNb3ZlKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuaXNNb3VzZURvd24pIHsgcmV0dXJuOyB9XG5cdFx0Y29uc3QgdHJhY2sgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHRsZXQgdmFsdWU7XG5cblx0XHRpZiAoXG5cdFx0XHRldmVudC5jbGllbnRYIC0gdHJhY2subGVmdCA8PSB0cmFjay53aWR0aFxuXHRcdFx0JiYgZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPj0gMFxuXHRcdCkge1xuXHRcdFx0dmFsdWUgPSB0aGlzLmNvbnZlcnRUb1ZhbHVlKGV2ZW50LmNsaWVudFggLSB0cmFjay5sZWZ0KTtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgbW91c2UgaXMgYmV5b25kIHRoZSBtYXgsIHNldCB0aGUgdmFsdWUgdG8gYG1heGBcblx0XHRpZiAoZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPiB0cmFjay53aWR0aCkge1xuXHRcdFx0dmFsdWUgPSB0aGlzLm1heDtcblx0XHR9XG5cblx0XHQvLyBpZiB0aGUgbW91c2UgaXMgYmVsb3cgdGhlIG1pbiwgc2V0IHRoZSB2YWx1ZSB0byBgbWluYFxuXHRcdGlmIChldmVudC5jbGllbnRYIC0gdHJhY2subGVmdCA8IDApIHtcblx0XHRcdHZhbHVlID0gdGhpcy5taW47XG5cdFx0fVxuXG5cdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3ZhbHVlW3RoaXMuX2ZvY3VzZWRUaHVtYkluZGV4XSA9IHZhbHVlO1xuXHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZXMgdGhlIGBvbk1vdXNlTW92ZWAgaGFuZGxlclxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRodW1iIElmIHRydWUgdGhlbiBgdGh1bWJgIGlzIGNsaWNrZWQgZG93biwgb3RoZXJ3aXNlIGB0aHVtYjJgIGlzIGNsaWNrZWQgZG93bi5cblx0ICovXG5cdG9uTW91c2VEb3duKGV2ZW50LCBpbmRleCA9IDApIHtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2ZvY3VzZWRUaHVtYkluZGV4ID0gaW5kZXg7XG5cdFx0dGhpcy50aHVtYnMudG9BcnJheSgpW2luZGV4XS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG5cdFx0dGhpcy5pc01vdXNlRG93biA9IHRydWU7XG5cdH1cblxuXHQvKiogRGlzYWJsZXMgdGhlIGBvbk1vdXNlTW92ZWAgaGFuZGxlciAqL1xuXHRvbk1vdXNlVXAoKSB7XG5cdFx0dGhpcy5pc01vdXNlRG93biA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGxzIGBpbmNyZW1lbnRWYWx1ZWAgZm9yIEFycm93UmlnaHQgYW5kIEFycm93VXAsIGBkZWNyZW1lbnRWYWx1ZWAgZm9yIEFycm93TGVmdCBhbmQgQXJyb3dEb3duLlxuXHQgKlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRodW1iIElmIHRydWUgdGhlbiBgdGh1bWJgIGlzIHByZXNzZWQgZG93biwgb3RoZXJ3aXNlIGB0aHVtYjJgIGlzIHByZXNzZWQgZG93bi5cblx0ICovXG5cdG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgaW5kZXggPSAwKSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZUFycm93S2V5cykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBtdWx0aXBsaWVyID0gZXZlbnQuc2hpZnRLZXkgPyB0aGlzLnNoaWZ0TXVsdGlwbGllciA6IDE7XG5cdFx0aWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIpIHtcblx0XHRcdHRoaXMuZGVjcmVtZW50VmFsdWUobXVsdGlwbGllciwgaW5kZXgpO1xuXHRcdFx0dGhpcy50aHVtYnMudG9BcnJheSgpW2luZGV4XS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93UmlnaHRcIiB8fCBldmVudC5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG5cdFx0XHR0aGlzLmluY3JlbWVudFZhbHVlKG11bHRpcGxpZXIsIGluZGV4KTtcblx0XHRcdHRoaXMudGh1bWJzLnRvQXJyYXkoKVtpbmRleF0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgaXNUZW1wbGF0ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmO1xuXHR9XG5cblx0LyoqIEdldCBvcHRpb25hbCBpbnB1dCBmaWVsZHMgKi9cblx0cHJvdGVjdGVkIGdldElucHV0cygpOiBIVE1MSW5wdXRFbGVtZW50W10ge1xuXHRcdHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQ6bm90KFt0eXBlPXJhbmdlXSlcIik7XG5cdH1cbn1cbiJdfQ==