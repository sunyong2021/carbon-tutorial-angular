/**
 *
 * carbon-angular v0.0.0 | checkbox.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, Output, ViewChild, HostListener } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
/**
 * Defines the set of states for a checkbox component.
 */
export var CheckboxState;
(function (CheckboxState) {
    CheckboxState[CheckboxState["Init"] = 0] = "Init";
    CheckboxState[CheckboxState["Indeterminate"] = 1] = "Indeterminate";
    CheckboxState[CheckboxState["Checked"] = 2] = "Checked";
    CheckboxState[CheckboxState["Unchecked"] = 3] = "Unchecked";
})(CheckboxState || (CheckboxState = {}));
/**
 * Used to emit changes performed on checkbox components.
 *
 * @deprecated since v4
 */
export class CheckboxChange {
}
/**
 * [See demo](../../?path=/story/checkbox--basic)
 *
 * <example-url>../../iframe.html?id=checkbox--basic</example-url>
 */
export class Checkbox {
    /**
     * Creates an instance of `Checkbox`.
     */
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        /**
         * Size of the checkbox.
         *
         * @deprecated since v4
         */
        this.size = "md";
        /**
         * Set to `true` for checkbox to be rendered without any classes on the host element.
         */
        this.inline = false;
        /**
         * Set to `true` for a disabled checkbox.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading checkbox.
         */
        this.skeleton = false;
        /**
         * Set to `true` to hide the checkbox labels.
         */
        this.hideLabel = false;
        /**
         * The unique id for the checkbox component.
         */
        this.id = `checkbox-${Checkbox.checkboxCount}`;
        // TODO: drop the `_`
        // tslint:disable-next-line:no-input-rename
        this._ariaLabel = "";
        /**
         * Emits click event.
         */
        this.click = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs on a checkbox after a
         * click.
         *
         * @deprecated since v4 use `checked` and `checkedChange` instead
         */
        this.change = new EventEmitter();
        /**
         * Emits an event when the value of the checkbox changes.
         *
         * Allows double biding with the `checked` Input.
         */
        this.checkedChange = new EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs specifically
         * on an indeterminate checkbox.
         */
        this.indeterminateChange = new EventEmitter();
        /**
         * Set to `true` if the input checkbox is selected (or checked).
         */
        this._checked = false;
        /**
         * Set to `true` if the input checkbox is in state indeterminate.
         */
        this._indeterminate = false;
        /**
         * Keeps a reference to the checkboxes current state, as defined in `CheckboxState`.
         */
        this.currentCheckboxState = CheckboxState.Init;
        /**
         * Called when checkbox is blurred. Needed to properly implement `ControlValueAccessor`.
         */
        this.onTouched = () => { };
        /**
         * Method set in `registerOnChange` to propagate changes back to the form.
         */
        this.propagateChange = (_) => { };
        Checkbox.checkboxCount++;
    }
    /**
     * Used to set the `aria-label` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabel` input instead
     */
    // tslint:disable-next-line:no-input-rename
    set ariaLabel(value) {
        this._ariaLabel = value;
    }
    get ariaLabel() {
        return this._ariaLabel;
    }
    /**
     * Used to set the `aria-labelledby` attribute on the input element.
     *
     * @deprecated since v4 use the `ariaLabelledby` input instead
     */
    // tslint:disable-next-line:no-input-rename
    set ariaLabelledby(value) {
        this._ariaLabelledby = value;
    }
    get ariaLabelledby() {
        return this._ariaLabelledby;
    }
    /**
     * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
     *
     * Allows double binding with the `indeterminateChange` Output.
     */
    set indeterminate(indeterminate) {
        if (indeterminate === this._indeterminate) {
            return;
        }
        this._indeterminate = indeterminate;
        if (this._indeterminate) {
            this.transitionCheckboxState(CheckboxState.Indeterminate);
        }
        else {
            this.transitionCheckboxState(this.checked ? CheckboxState.Checked : CheckboxState.Unchecked);
        }
        if (this.inputCheckbox && this.inputCheckbox.nativeElement) {
            this.inputCheckbox.nativeElement.indeterminate = indeterminate;
        }
        this.changeDetectorRef.markForCheck();
        this.indeterminateChange.emit(this._indeterminate);
    }
    /**
     * Reflects whether the checkbox state is indeterminate.
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * Sets the `checked` state. `true` for checked, `false` for unchecked
     *
     * Allows double binding with the `checkedChange` Output.
     */
    set checked(checked) {
        this.setChecked(checked, false);
    }
    /**
     * Returns value `true` if state is selected for the checkbox.
     */
    get checked() {
        return this._checked;
    }
    /**
     * Toggle the selected state of the checkbox.
     */
    toggle() {
        // Flip checked and reset indeterminate
        this.setChecked(!this.checked, true);
    }
    /**
     * Writes a value from `ngModel` to the component.
     *
     * In this case the value is the `checked` property.
     *
     * @param value boolean, corresponds to the `checked` property.
     */
    writeValue(value) {
        // Set checked and reset indeterminate
        this.setChecked(!!value, true);
    }
    /**
     * Sets a method in order to propagate changes back to the form.
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the checkbox.
     *
     * ex: `this.formGroup.get("myCheckbox").disable();`
     *
     * @param isDisabled `true` to disable the checkbox
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.inputCheckbox.nativeElement.disabled = this.disabled;
    }
    focusOut() {
        this.onTouched();
    }
    /**
     * Executes on the event of a change within `Checkbox` to block propagation.
     */
    onChange(event) {
        event.stopPropagation();
    }
    /**
     * Handles click events on the `Checkbox` and emits changes to other classes.
     */
    onClick(event) {
        if (this.click.observers.length) {
            // Disable default checkbox activation behavior which flips checked and resets indeterminate.
            // This allows the parent component to control the checked/indeterminate properties.
            event.preventDefault();
            this.click.emit();
            return;
        }
        if (!this.disabled) {
            this.toggle();
            this.transitionCheckboxState(this._checked ? CheckboxState.Checked : CheckboxState.Unchecked);
            this.emitChangeEvent();
        }
    }
    /**
     * Handles changes between checkbox states.
     */
    transitionCheckboxState(newState) {
        this.currentCheckboxState = newState;
    }
    /**
     * Creates instance of `CheckboxChange` used to propagate the change event.
     */
    emitChangeEvent() {
        /* begin deprecation */
        let event = new CheckboxChange();
        event.source = this;
        event.checked = this.checked;
        this.change.emit(event);
        /* end deprecation */
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    /**
     * Updates the checkbox if it is in the indeterminate state.
     */
    ngAfterViewInit() {
        if (this.indeterminate && this.inputCheckbox && this.inputCheckbox.nativeElement) {
            this.inputCheckbox.nativeElement.indeterminate = true;
        }
    }
    /**
     * Sets checked state and optionally resets indeterminate state.
     */
    setChecked(checked, resetIndeterminate) {
        if (checked === this._checked) {
            return;
        }
        this._checked = checked;
        // Reset indeterminate if requested
        if (resetIndeterminate && this._indeterminate) {
            this._indeterminate = false;
            Promise.resolve().then(() => {
                this.indeterminateChange.emit(this._indeterminate);
            });
        }
        this.changeDetectorRef.markForCheck();
    }
}
/**
 * Variable used for creating unique ids for checkbox components.
 */
Checkbox.checkboxCount = 0;
Checkbox.decorators = [
    { type: Component, args: [{
                selector: "ibm-checkbox",
                template: `
		<div class="bx--form-item bx--checkbox-wrapper">
			<input
				#inputCheckbox
				class="bx--checkbox"
				type="checkbox"
				[id]="id + '_input'"
				[value]="value"
				[name]="name"
				[required]="required"
				[checked]="checked"
				[disabled]="disabled"
				[attr.aria-labelledby]="ariaLabelledby"
				[attr.aria-checked]="(indeterminate ? 'mixed' : checked)"
				(change)="onChange($event)"
				(click)="onClick($event)">
			<label
				[for]="id + '_input'"
				[attr.aria-label]="ariaLabel"
				class="bx--checkbox-label"
				[ngClass]="{
					'bx--skeleton' : skeleton
				}">
				<span [ngClass]="{'bx--visually-hidden' : hideLabel}" class="bx--checkbox-label-text">
					<ng-content></ng-content>
				</span>
			</label>
		</div>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Checkbox,
                        multi: true
                    }
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
Checkbox.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
Checkbox.propDecorators = {
    size: [{ type: Input }],
    nested: [{ type: Input }],
    inline: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    hideLabel: [{ type: Input }],
    name: [{ type: Input }],
    id: [{ type: Input }],
    required: [{ type: Input }],
    value: [{ type: Input }],
    ariaLabel: [{ type: Input, args: ["aria-label",] }],
    _ariaLabel: [{ type: Input, args: ["ariaLabel",] }],
    ariaLabelledby: [{ type: Input, args: ["aria-labelledby",] }],
    _ariaLabelledby: [{ type: Input, args: ["ariaLabelledby",] }],
    indeterminate: [{ type: Input }],
    checked: [{ type: Input }],
    click: [{ type: Output }],
    change: [{ type: Output }],
    checkedChange: [{ type: Output }],
    indeterminateChange: [{ type: Output }],
    inputCheckbox: [{ type: ViewChild, args: ["inputCheckbox", { static: false },] }],
    focusOut: [{ type: HostListener, args: ["focusout",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hlY2tib3guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9jaGVja2JveC8iLCJzb3VyY2VzIjpbImNoZWNrYm94LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLFNBQVMsRUFFVCxZQUFZLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUF3QixNQUFNLGdCQUFnQixDQUFDO0FBR3pFOztHQUVHO0FBQ0gsTUFBTSxDQUFOLElBQVksYUFLWDtBQUxELFdBQVksYUFBYTtJQUN4QixpREFBSSxDQUFBO0lBQ0osbUVBQWEsQ0FBQTtJQUNiLHVEQUFPLENBQUE7SUFDUCwyREFBUyxDQUFBO0FBQ1YsQ0FBQyxFQUxXLGFBQWEsS0FBYixhQUFhLFFBS3hCO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sT0FBTyxjQUFjO0NBUzFCO0FBRUQ7Ozs7R0FJRztBQXlDSCxNQUFNLE9BQU8sUUFBUTtJQW1McEI7O09BRUc7SUFDSCxZQUFzQixpQkFBb0M7UUFBcEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQWhMMUQ7Ozs7V0FJRztRQUNNLFNBQUksR0FBZ0IsSUFBSSxDQUFDO1FBT2xDOztXQUVHO1FBQ00sV0FBTSxHQUFHLEtBQUssQ0FBQztRQUN4Qjs7V0FFRztRQUNNLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDMUI7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQzFCOztXQUVHO1FBQ00sY0FBUyxHQUFHLEtBQUssQ0FBQztRQUszQjs7V0FFRztRQUNNLE9BQUUsR0FBRyxZQUFZLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQXVCbkQscUJBQXFCO1FBQ3JCLDJDQUEyQztRQUN2Qixl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QzNCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ3BELENBQUMsQ0FBQyxDQUFDO1NBQ0g7UUFDRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdkMsQ0FBQzs7QUFoVUQ7O0dBRUc7QUFDSSxzQkFBYSxHQUFHLENBQUMsQ0FBQzs7WUE1Q3pCLFNBQVMsU0FBQztnQkFDVixRQUFRLEVBQUUsY0FBYztnQkFDeEIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNEJUO2dCQUNELFNBQVMsRUFBRTtvQkFDVjt3QkFDQyxPQUFPLEVBQUUsaUJBQWlCO3dCQUMxQixXQUFXLEVBQUUsUUFBUTt3QkFDckIsS0FBSyxFQUFFLElBQUk7cUJBQ1g7aUJBQ0Q7Z0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDL0M7Ozs7WUFuRkEsaUJBQWlCOzs7bUJBK0ZoQixLQUFLO3FCQU1MLEtBQUs7cUJBSUwsS0FBSzt1QkFJTCxLQUFLO3VCQUlMLEtBQUs7d0JBSUwsS0FBSzttQkFJTCxLQUFLO2lCQUlMLEtBQUs7dUJBSUwsS0FBSztvQkFJTCxLQUFLO3dCQU9MLEtBQUssU0FBQyxZQUFZO3lCQVVsQixLQUFLLFNBQUMsV0FBVzs2QkFRakIsS0FBSyxTQUFDLGlCQUFpQjs4QkFVdkIsS0FBSyxTQUFDLGdCQUFnQjs0QkFPdEIsS0FBSztzQkFnQ0wsS0FBSztvQkFjTCxNQUFNO3FCQU9OLE1BQU07NEJBT04sTUFBTTtrQ0FNTixNQUFNOzRCQW9CTixTQUFTLFNBQUMsZUFBZSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTt1QkF3RDVDLFlBQVksU0FBQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QWZ0ZXJWaWV3SW5pdCxcblx0Q2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG5cdENoYW5nZURldGVjdG9yUmVmLFxuXHRDb21wb25lbnQsXG5cdEVsZW1lbnRSZWYsXG5cdEV2ZW50RW1pdHRlcixcblx0SW5wdXQsXG5cdE91dHB1dCxcblx0Vmlld0NoaWxkLFxuXHRIb3N0QmluZGluZyxcblx0SG9zdExpc3RlbmVyXG59IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiwgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IENoZWNrYm94VmFsdWUgfSBmcm9tIFwiLi9jaGVja2JveC50eXBlc1wiO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIHNldCBvZiBzdGF0ZXMgZm9yIGEgY2hlY2tib3ggY29tcG9uZW50LlxuICovXG5leHBvcnQgZW51bSBDaGVja2JveFN0YXRlIHtcblx0SW5pdCxcblx0SW5kZXRlcm1pbmF0ZSxcblx0Q2hlY2tlZCxcblx0VW5jaGVja2VkXG59XG5cbi8qKlxuICogVXNlZCB0byBlbWl0IGNoYW5nZXMgcGVyZm9ybWVkIG9uIGNoZWNrYm94IGNvbXBvbmVudHMuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcbiAqL1xuZXhwb3J0IGNsYXNzIENoZWNrYm94Q2hhbmdlIHtcblx0LyoqXG5cdCAqIENvbnRhaW5zIHRoZSBgQ2hlY2tib3hgIHRoYXQgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICovXG5cdHNvdXJjZTogQ2hlY2tib3g7XG5cdC8qKlxuXHQgKiBUaGUgc3RhdGUgb2YgdGhlIGBDaGVja2JveGAgZW5jb21wYXNzZWQgaW4gdGhlIGBDaGVja2JveENoYW5nZWAgY2xhc3MuXG5cdCAqL1xuXHRjaGVja2VkOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L2NoZWNrYm94LS1iYXNpYylcbiAqXG4gKiA8ZXhhbXBsZS11cmw+Li4vLi4vaWZyYW1lLmh0bWw/aWQ9Y2hlY2tib3gtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1jaGVja2JveFwiLFxuXHR0ZW1wbGF0ZTogYFxuXHRcdDxkaXYgY2xhc3M9XCJieC0tZm9ybS1pdGVtIGJ4LS1jaGVja2JveC13cmFwcGVyXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0I2lucHV0Q2hlY2tib3hcblx0XHRcdFx0Y2xhc3M9XCJieC0tY2hlY2tib3hcIlxuXHRcdFx0XHR0eXBlPVwiY2hlY2tib3hcIlxuXHRcdFx0XHRbaWRdPVwiaWQgKyAnX2lucHV0J1wiXG5cdFx0XHRcdFt2YWx1ZV09XCJ2YWx1ZVwiXG5cdFx0XHRcdFtuYW1lXT1cIm5hbWVcIlxuXHRcdFx0XHRbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuXHRcdFx0XHRbY2hlY2tlZF09XCJjaGVja2VkXCJcblx0XHRcdFx0W2Rpc2FibGVkXT1cImRpc2FibGVkXCJcblx0XHRcdFx0W2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcblx0XHRcdFx0W2F0dHIuYXJpYS1jaGVja2VkXT1cIihpbmRldGVybWluYXRlID8gJ21peGVkJyA6IGNoZWNrZWQpXCJcblx0XHRcdFx0KGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcblx0XHRcdFx0KGNsaWNrKT1cIm9uQ2xpY2soJGV2ZW50KVwiPlxuXHRcdFx0PGxhYmVsXG5cdFx0XHRcdFtmb3JdPVwiaWQgKyAnX2lucHV0J1wiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcblx0XHRcdFx0Y2xhc3M9XCJieC0tY2hlY2tib3gtbGFiZWxcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0J2J4LS1za2VsZXRvbicgOiBza2VsZXRvblxuXHRcdFx0XHR9XCI+XG5cdFx0XHRcdDxzcGFuIFtuZ0NsYXNzXT1cInsnYngtLXZpc3VhbGx5LWhpZGRlbicgOiBoaWRlTGFiZWx9XCIgY2xhc3M9XCJieC0tY2hlY2tib3gtbGFiZWwtdGV4dFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9sYWJlbD5cblx0XHQ8L2Rpdj5cblx0YCxcblx0cHJvdmlkZXJzOiBbXG5cdFx0e1xuXHRcdFx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdFx0XHR1c2VFeGlzdGluZzogQ2hlY2tib3gsXG5cdFx0XHRtdWx0aTogdHJ1ZVxuXHRcdH1cblx0XSxcblx0Y2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3ggaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgQWZ0ZXJWaWV3SW5pdCB7XG5cdC8qKlxuXHQgKiBWYXJpYWJsZSB1c2VkIGZvciBjcmVhdGluZyB1bmlxdWUgaWRzIGZvciBjaGVja2JveCBjb21wb25lbnRzLlxuXHQgKi9cblx0c3RhdGljIGNoZWNrYm94Q291bnQgPSAwO1xuXG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSBjaGVja2JveC5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcblx0ICovXG5cdEBJbnB1dCgpIHNpemU6IFwic21cIiB8IFwibWRcIiA9IFwibWRcIjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGNoZWNrYm94IHRvIGJlIHJlbmRlcmVkIHdpdGggbmVzdGVkIHN0eWxlcy5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjRcblx0ICovXG5cdEBJbnB1dCgpIG5lc3RlZDogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgZm9yIGNoZWNrYm94IHRvIGJlIHJlbmRlcmVkIHdpdGhvdXQgYW55IGNsYXNzZXMgb24gdGhlIGhvc3QgZWxlbWVudC5cblx0ICovXG5cdEBJbnB1dCgpIGlubGluZSA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkaXNhYmxlZCBjaGVja2JveC5cblx0ICovXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgY2hlY2tib3guXG5cdCAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKipcblx0ICogU2V0IHRvIGB0cnVlYCB0byBoaWRlIHRoZSBjaGVja2JveCBsYWJlbHMuXG5cdCAqL1xuXHRASW5wdXQoKSBoaWRlTGFiZWwgPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldHMgdGhlIG5hbWUgYXR0cmlidXRlIG9uIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSBuYW1lOiBzdHJpbmc7XG5cdC8qKlxuXHQgKiBUaGUgdW5pcXVlIGlkIGZvciB0aGUgY2hlY2tib3ggY29tcG9uZW50LlxuXHQgKi9cblx0QElucHV0KCkgaWQgPSBgY2hlY2tib3gtJHtDaGVja2JveC5jaGVja2JveENvdW50fWA7XG5cdC8qKlxuXHQgKiBSZWZsZWN0cyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIG9mIHRoZSBgaW5wdXRgIGVsZW1lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbjtcblx0LyoqXG5cdCAqIFNldHMgdGhlIHZhbHVlIGF0dHJpYnV0ZSBvbiB0aGUgYGlucHV0YCBlbGVtZW50LlxuXHQgKi9cblx0QElucHV0KCkgdmFsdWU6IENoZWNrYm94VmFsdWU7XG5cdC8qKlxuXHQgKiBVc2VkIHRvIHNldCB0aGUgYGFyaWEtbGFiZWxgIGF0dHJpYnV0ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cblx0ICpcblx0ICogQGRlcHJlY2F0ZWQgc2luY2UgdjQgdXNlIHRoZSBgYXJpYUxhYmVsYCBpbnB1dCBpbnN0ZWFkXG5cdCAqL1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG5cdEBJbnB1dChcImFyaWEtbGFiZWxcIikgc2V0IGFyaWFMYWJlbCh2YWx1ZTogc3RyaW5nKSB7XG5cdFx0dGhpcy5fYXJpYUxhYmVsID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgYXJpYUxhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcmlhTGFiZWw7XG5cdH1cblxuXHQvLyBUT0RPOiBkcm9wIHRoZSBgX2Bcblx0Ly8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuXHRASW5wdXQoXCJhcmlhTGFiZWxcIikgX2FyaWFMYWJlbCA9IFwiXCI7XG5cblx0LyoqXG5cdCAqIFVzZWQgdG8gc2V0IHRoZSBgYXJpYS1sYWJlbGxlZGJ5YCBhdHRyaWJ1dGUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBkZXByZWNhdGVkIHNpbmNlIHY0IHVzZSB0aGUgYGFyaWFMYWJlbGxlZGJ5YCBpbnB1dCBpbnN0ZWFkXG5cdCAqL1xuXHQvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG5cdEBJbnB1dChcImFyaWEtbGFiZWxsZWRieVwiKSBzZXQgYXJpYUxhYmVsbGVkYnkodmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuX2FyaWFMYWJlbGxlZGJ5ID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgYXJpYUxhYmVsbGVkYnkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FyaWFMYWJlbGxlZGJ5O1xuXHR9XG5cblx0Ly8gVE9ETzogZHJvcCB0aGUgYF9gXG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcblx0QElucHV0KFwiYXJpYUxhYmVsbGVkYnlcIikgX2FyaWFMYWJlbGxlZGJ5OiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY2hlY2tib3gncyBpbmRldGVybWluYXRlIHN0YXRlIHRvIG1hdGNoIHRoZSBwYXJhbWV0ZXIgYW5kIHRyYW5zaXRpb24gdGhlIHZpZXcgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuXHQgKlxuXHQgKiBBbGxvd3MgZG91YmxlIGJpbmRpbmcgd2l0aCB0aGUgYGluZGV0ZXJtaW5hdGVDaGFuZ2VgIE91dHB1dC5cblx0ICovXG5cdEBJbnB1dCgpIHNldCBpbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4pIHtcblx0XHRpZiAoaW5kZXRlcm1pbmF0ZSA9PT0gdGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuXG5cdFx0aWYgKHRoaXMuX2luZGV0ZXJtaW5hdGUpIHtcblx0XHRcdHRoaXMudHJhbnNpdGlvbkNoZWNrYm94U3RhdGUoQ2hlY2tib3hTdGF0ZS5JbmRldGVybWluYXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy50cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZSh0aGlzLmNoZWNrZWQgPyBDaGVja2JveFN0YXRlLkNoZWNrZWQgOiBDaGVja2JveFN0YXRlLlVuY2hlY2tlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaW5wdXRDaGVja2JveCAmJiB0aGlzLmlucHV0Q2hlY2tib3gubmF0aXZlRWxlbWVudCkge1xuXHRcdFx0dGhpcy5pbnB1dENoZWNrYm94Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG5cdFx0fVxuXHRcdHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG5cdFx0dGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmVmbGVjdHMgd2hldGhlciB0aGUgY2hlY2tib3ggc3RhdGUgaXMgaW5kZXRlcm1pbmF0ZS5cblx0ICovXG5cdGdldCBpbmRldGVybWluYXRlKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGBjaGVja2VkYCBzdGF0ZS4gYHRydWVgIGZvciBjaGVja2VkLCBgZmFsc2VgIGZvciB1bmNoZWNrZWRcblx0ICpcblx0ICogQWxsb3dzIGRvdWJsZSBiaW5kaW5nIHdpdGggdGhlIGBjaGVja2VkQ2hhbmdlYCBPdXRwdXQuXG5cdCAqL1xuXHRASW5wdXQoKSBzZXQgY2hlY2tlZCAoY2hlY2tlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuc2V0Q2hlY2tlZChjaGVja2VkLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB2YWx1ZSBgdHJ1ZWAgaWYgc3RhdGUgaXMgc2VsZWN0ZWQgZm9yIHRoZSBjaGVja2JveC5cblx0ICovXG5cdGdldCBjaGVja2VkKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVtaXRzIGNsaWNrIGV2ZW50LlxuXHQgKi9cblx0QE91dHB1dCgpIGNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXHQvKipcblx0ICogRW1pdHMgZXZlbnQgbm90aWZ5aW5nIG90aGVyIGNsYXNzZXMgd2hlbiBhIGNoYW5nZSBpbiBzdGF0ZSBvY2N1cnMgb24gYSBjaGVja2JveCBhZnRlciBhXG5cdCAqIGNsaWNrLlxuXHQgKlxuXHQgKiBAZGVwcmVjYXRlZCBzaW5jZSB2NCB1c2UgYGNoZWNrZWRgIGFuZCBgY2hlY2tlZENoYW5nZWAgaW5zdGVhZFxuXHQgKi9cblx0QE91dHB1dCgpIGNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY2hlY2tib3ggY2hhbmdlcy5cblx0ICpcblx0ICogQWxsb3dzIGRvdWJsZSBiaWRpbmcgd2l0aCB0aGUgYGNoZWNrZWRgIElucHV0LlxuXHQgKi9cblx0QE91dHB1dCgpIGNoZWNrZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyBvdGhlciBjbGFzc2VzIHdoZW4gYSBjaGFuZ2UgaW4gc3RhdGUgb2NjdXJzIHNwZWNpZmljYWxseVxuXHQgKiBvbiBhbiBpbmRldGVybWluYXRlIGNoZWNrYm94LlxuXHQgKi9cblx0QE91dHB1dCgpIGluZGV0ZXJtaW5hdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cblx0LyoqXG5cdCAqIFNldCB0byBgdHJ1ZWAgaWYgdGhlIGlucHV0IGNoZWNrYm94IGlzIHNlbGVjdGVkIChvciBjaGVja2VkKS5cblx0ICovXG5cdF9jaGVja2VkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBpbnB1dCBjaGVja2JveCBpcyBpbiBzdGF0ZSBpbmRldGVybWluYXRlLlxuXHQgKi9cblx0X2luZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuXHQvKipcblx0ICogS2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGNoZWNrYm94ZXMgY3VycmVudCBzdGF0ZSwgYXMgZGVmaW5lZCBpbiBgQ2hlY2tib3hTdGF0ZWAuXG5cdCAqL1xuXHRjdXJyZW50Q2hlY2tib3hTdGF0ZSA9IENoZWNrYm94U3RhdGUuSW5pdDtcblxuXHQvKipcblx0ICogTWFpbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSB2aWV3IERPTSBlbGVtZW50IG9mIHRoZSBgQ2hlY2tib3hgLlxuXHQgKi9cblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwiaW5wdXRDaGVja2JveFwiLCB7IHN0YXRpYzogZmFsc2UgfSkgaW5wdXRDaGVja2JveDogRWxlbWVudFJlZjtcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgQ2hlY2tib3hgLlxuXHQgKi9cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuXHRcdENoZWNrYm94LmNoZWNrYm94Q291bnQrKztcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBjaGVja2JveC5cblx0ICovXG5cdHB1YmxpYyB0b2dnbGUoKSB7XG5cdFx0Ly8gRmxpcCBjaGVja2VkIGFuZCByZXNldCBpbmRldGVybWluYXRlXG5cdFx0dGhpcy5zZXRDaGVja2VkKCF0aGlzLmNoZWNrZWQsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHZhbHVlIGZyb20gYG5nTW9kZWxgIHRvIHRoZSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIEluIHRoaXMgY2FzZSB0aGUgdmFsdWUgaXMgdGhlIGBjaGVja2VkYCBwcm9wZXJ0eS5cblx0ICpcblx0ICogQHBhcmFtIHZhbHVlIGJvb2xlYW4sIGNvcnJlc3BvbmRzIHRvIHRoZSBgY2hlY2tlZGAgcHJvcGVydHkuXG5cdCAqL1xuXHRwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG5cdFx0Ly8gU2V0IGNoZWNrZWQgYW5kIHJlc2V0IGluZGV0ZXJtaW5hdGVcblx0XHR0aGlzLnNldENoZWNrZWQoISF2YWx1ZSwgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyBhIG1ldGhvZCBpbiBvcmRlciB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaGFzIGJlZW4gdG91Y2hlZC5cblx0ICogQHBhcmFtIGZuIENhbGxiYWNrIHRvIGJlIHRyaWdnZXJlZCB3aGVuIHRoZSBjaGVja2JveCBpcyB0b3VjaGVkLlxuXHQgKi9cblx0cHVibGljIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCA9IGZuO1xuXHR9XG5cblx0LyoqXG5cdCAqIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgbWV0aG9kIHRvIHByb2dyYW1tYXRpY2FsbHkgZGlzYWJsZSB0aGUgY2hlY2tib3guXG5cdCAqXG5cdCAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlDaGVja2JveFwiKS5kaXNhYmxlKCk7YFxuXHQgKlxuXHQgKiBAcGFyYW0gaXNEaXNhYmxlZCBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgY2hlY2tib3hcblx0ICovXG5cdHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXHRcdHRoaXMuaW5wdXRDaGVja2JveC5uYXRpdmVFbGVtZW50LmRpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcblx0fVxuXG5cdEBIb3N0TGlzdGVuZXIoXCJmb2N1c291dFwiKVxuXHRmb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEV4ZWN1dGVzIG9uIHRoZSBldmVudCBvZiBhIGNoYW5nZSB3aXRoaW4gYENoZWNrYm94YCB0byBibG9jayBwcm9wYWdhdGlvbi5cblx0ICovXG5cdG9uQ2hhbmdlKGV2ZW50OiBFdmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIG9uIHRoZSBgQ2hlY2tib3hgIGFuZCBlbWl0cyBjaGFuZ2VzIHRvIG90aGVyIGNsYXNzZXMuXG5cdCAqL1xuXHRvbkNsaWNrKGV2ZW50OiBFdmVudCkge1xuXHRcdGlmICh0aGlzLmNsaWNrLm9ic2VydmVycy5sZW5ndGgpIHtcblx0XHRcdC8vIERpc2FibGUgZGVmYXVsdCBjaGVja2JveCBhY3RpdmF0aW9uIGJlaGF2aW9yIHdoaWNoIGZsaXBzIGNoZWNrZWQgYW5kIHJlc2V0cyBpbmRldGVybWluYXRlLlxuXHRcdFx0Ly8gVGhpcyBhbGxvd3MgdGhlIHBhcmVudCBjb21wb25lbnQgdG8gY29udHJvbCB0aGUgY2hlY2tlZC9pbmRldGVybWluYXRlIHByb3BlcnRpZXMuXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dGhpcy5jbGljay5lbWl0KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICghdGhpcy5kaXNhYmxlZCkge1xuXHRcdFx0dGhpcy50b2dnbGUoKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbkNoZWNrYm94U3RhdGUodGhpcy5fY2hlY2tlZCA/IENoZWNrYm94U3RhdGUuQ2hlY2tlZCA6IENoZWNrYm94U3RhdGUuVW5jaGVja2VkKTtcblx0XHRcdHRoaXMuZW1pdENoYW5nZUV2ZW50KCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBgQ29udHJvbFZhbHVlQWNjZXNzb3JgLlxuXHQgKi9cblx0b25Ub3VjaGVkOiAoKSA9PiBhbnkgPSAoKSA9PiB7fTtcblxuXHQvKipcblx0ICogSGFuZGxlcyBjaGFuZ2VzIGJldHdlZW4gY2hlY2tib3ggc3RhdGVzLlxuXHQgKi9cblx0dHJhbnNpdGlvbkNoZWNrYm94U3RhdGUobmV3U3RhdGU6IENoZWNrYm94U3RhdGUpIHtcblx0XHR0aGlzLmN1cnJlbnRDaGVja2JveFN0YXRlID0gbmV3U3RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBpbnN0YW5jZSBvZiBgQ2hlY2tib3hDaGFuZ2VgIHVzZWQgdG8gcHJvcGFnYXRlIHRoZSBjaGFuZ2UgZXZlbnQuXG5cdCAqL1xuXHRlbWl0Q2hhbmdlRXZlbnQoKSB7XG5cdFx0LyogYmVnaW4gZGVwcmVjYXRpb24gKi9cblx0XHRsZXQgZXZlbnQgPSBuZXcgQ2hlY2tib3hDaGFuZ2UoKTtcblx0XHRldmVudC5zb3VyY2UgPSB0aGlzO1xuXHRcdGV2ZW50LmNoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG5cdFx0dGhpcy5jaGFuZ2UuZW1pdChldmVudCk7XG5cdFx0LyogZW5kIGRlcHJlY2F0aW9uICovXG5cblx0XHR0aGlzLmNoZWNrZWRDaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuXHRcdHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlcyB0aGUgY2hlY2tib3ggaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG5cdCAqL1xuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0aWYgKHRoaXMuaW5kZXRlcm1pbmF0ZSAmJiB0aGlzLmlucHV0Q2hlY2tib3ggJiYgdGhpcy5pbnB1dENoZWNrYm94Lm5hdGl2ZUVsZW1lbnQpIHtcblx0XHRcdHRoaXMuaW5wdXRDaGVja2JveC5uYXRpdmVFbGVtZW50LmluZGV0ZXJtaW5hdGUgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBNZXRob2Qgc2V0IGluIGByZWdpc3Rlck9uQ2hhbmdlYCB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuXHQgKi9cblx0cHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4ge307XG5cblx0LyoqXG5cdCAqIFNldHMgY2hlY2tlZCBzdGF0ZSBhbmQgb3B0aW9uYWxseSByZXNldHMgaW5kZXRlcm1pbmF0ZSBzdGF0ZS5cblx0ICovXG5cdHByaXZhdGUgc2V0Q2hlY2tlZChjaGVja2VkOiBib29sZWFuLCByZXNldEluZGV0ZXJtaW5hdGU6IGJvb2xlYW4pIHtcblx0XHRpZiAoY2hlY2tlZCA9PT0gdGhpcy5fY2hlY2tlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9jaGVja2VkID0gY2hlY2tlZDtcblx0XHQvLyBSZXNldCBpbmRldGVybWluYXRlIGlmIHJlcXVlc3RlZFxuXHRcdGlmIChyZXNldEluZGV0ZXJtaW5hdGUgJiYgdGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuXHRcdFx0dGhpcy5faW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuXHRcdFx0UHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdHRoaXMuaW5kZXRlcm1pbmF0ZUNoYW5nZS5lbWl0KHRoaXMuX2luZGV0ZXJtaW5hdGUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG5cdH1cbn1cbiJdfQ==