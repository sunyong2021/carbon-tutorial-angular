/**
 *
 * carbon-angular v0.0.0 | table-body.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, Input, EventEmitter, Output } from "@angular/core";
import { TableModel } from "../table-model.class";
import { I18n } from "carbon-components-angular/i18n";
export class TableBody {
    constructor(i18n) {
        this.i18n = i18n;
        /**
         * Controls whether to enable multiple or single row selection.
         */
        this.enableSingleSelect = false;
        /**
         * Controls whether to show the selection checkboxes column or not.
         */
        this.showSelectionColumn = true;
        /**
         * Size of the table rows.
         */
        this.size = "md";
        this.skeleton = false;
        /**
         * Emits if a single row is selected.
         *
         * @param ({model: this.model, selectedRowIndex: index})
         */
        this.selectRow = new EventEmitter();
        /**
         * Emits if a single row is deselected.
         *
         * @param ({model: this.model, deselectedRowIndex: index})
         */
        this.deselectRow = new EventEmitter();
        /**
         * Emits if a row item excluding expandButtons, checkboxes, or radios is clicked.
         */
        this.rowClick = new EventEmitter();
        this._checkboxRowLabel = this.i18n.getOverridable("TABLE.CHECKBOX_ROW");
        this._expandButtonAriaLabel = this.i18n.getOverridable("TABLE.EXPAND_BUTTON");
    }
    set expandButtonAriaLabel(value) {
        this._expandButtonAriaLabel.override(value);
    }
    get expandButtonAriaLabel() {
        return this._expandButtonAriaLabel.value;
    }
    set checkboxRowLabel(value) {
        this._checkboxRowLabel.override(value);
    }
    get checkboxRowLabel() {
        return this._checkboxRowLabel.value;
    }
    /**
     * Triggered when a single row is clicked.
     * Updates the header checkbox state.
     * Emits the `selectRow` or `deselectRow` event.
     */
    onRowCheckboxChange(index) {
        if (this.model.isRowSelected(index)) {
            this.deselectRow.emit({ model: this.model, deselectedRowIndex: index });
        }
        else {
            this.selectRow.emit({ model: this.model, selectedRowIndex: index });
        }
    }
    onRowClick(index) {
        this.rowClick.emit(index);
    }
    getCheckboxRowLabel() {
        return this._checkboxRowLabel.subject;
    }
    getExpandButtonAriaLabel() {
        return this._expandButtonAriaLabel.subject;
    }
    firstExpandedDataInRow(row) {
        const found = row.find(d => d.expandedData);
        if (found) {
            return found.expandedData;
        }
        return found;
    }
    shouldExpandAsTable(row) {
        return row.some(d => d.expandAsTable);
    }
}
TableBody.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line: component-selector
                selector: "[ibmTableBody]",
                template: `
		<ng-container *ngIf="model">
			<ng-container *ngFor="let row of model.data; let i = index">
				<tr
					ibmTableRow
					[model]="model"
					[row]="row"
					[size]="size"
					[selected]="model.isRowSelected(i)"
					[expandable]="model.isRowExpandable(i)"
					[expanded]="model.isRowExpanded(i)"
					[checkboxLabel]="getCheckboxRowLabel()"
					[expandButtonAriaLabel]="getExpandButtonAriaLabel()"
					[showSelectionColumn]="showSelectionColumn"
					[enableSingleSelect]="enableSingleSelect"
					[skeleton]="skeleton"
					(selectRow)="onRowCheckboxChange(i)"
					(deselectRow)="onRowCheckboxChange(i)"
					(expandRow)="model.expandRow(i, !model.isRowExpanded(i))"
					(rowClick)="onRowClick(i)"
					*ngIf="!model.isRowFiltered(i)"
					[class]="(model.rowsClass[i] ? model.rowsClass[i] : null)"
					[ngClass]="{
						'tbody_row--success': !model.isRowSelected(i) && model.getRowContext(i) === 'success',
						'tbody_row--warning': !model.isRowSelected(i) && model.getRowContext(i) === 'warning',
						'tbody_row--info': !model.isRowSelected(i) && model.getRowContext(i) === 'info',
						'tbody_row--error': !model.isRowSelected(i) && model.getRowContext(i) === 'error'
					}">
				</tr>
				<tr
					*ngIf="model.isRowExpandable(i) && !shouldExpandAsTable(row) && !model.isRowFiltered(i)"
					ibmTableExpandedRow
					ibmExpandedRowHover
					[row]="row"
					[expanded]="model.isRowExpanded(i)"
					[skeleton]="skeleton">
				</tr>
				<ng-container
					*ngIf="model.isRowExpandable(i) && shouldExpandAsTable(row) && model.isRowExpanded(i) && !model.isRowFiltered(i)">
					<tr
						*ngFor="let expandedDataRow of firstExpandedDataInRow(row)"
						ibmTableRow
						[model]="model"
						[showSelectionColumnCheckbox]="false"
						[showSelectionColumn]="showSelectionColumn"
						[row]="expandedDataRow"
						[size]="size"
						[skeleton]="skeleton">
					</tr>
				</ng-container>
			</ng-container>
		</ng-container>
		<ng-content></ng-content>
	`
            }] }
];
/** @nocollapse */
TableBody.ctorParameters = () => [
    { type: I18n }
];
TableBody.propDecorators = {
    model: [{ type: Input }],
    enableSingleSelect: [{ type: Input }],
    expandButtonAriaLabel: [{ type: Input }],
    checkboxRowLabel: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    size: [{ type: Input }],
    selectionLabelColumn: [{ type: Input }],
    skeleton: [{ type: Input }],
    selectRow: [{ type: Output }],
    deselectRow: [{ type: Output }],
    rowClick: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtYm9keS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3RhYmxlLyIsInNvdXJjZXMiOlsiYm9keS90YWJsZS1ib2R5LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxZQUFZLEVBQ1osTUFBTSxFQUNOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsSUFBSSxFQUFlLE1BQU0sZ0NBQWdDLENBQUM7QUE4RG5FLE1BQU0sT0FBTyxTQUFTO0lBd0VyQixZQUFzQixJQUFVO1FBQVYsU0FBSSxHQUFKLElBQUksQ0FBTTtRQXJFaEM7O1dBRUc7UUFDTSx1QkFBa0IsR0FBRyxLQUFLLENBQUM7UUFvQnBDOztXQUVHO1FBQ00sd0JBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRXBDOztXQUVHO1FBQ00sU0FBSSxHQUFpQixJQUFJLENBQUM7UUFjMUIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUUxQjs7OztXQUlHO1FBQ08sY0FBUyxHQUFHLElBQUksWUFBWSxFQUFVLENBQUM7UUFFakQ7Ozs7V0FJRztRQUNPLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUVuRDs7V0FFRztRQUNPLGFBQVEsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDO1FBRXRDLHNCQUFpQixHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDbkUsMkJBQXNCLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUUvQyxDQUFDO0lBaEVyQyxJQUNJLHFCQUFxQixDQUFDLEtBQWtDO1FBQzNELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVELElBQUkscUJBQXFCO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQztJQUMxQyxDQUFDO0lBRUQsSUFDSSxnQkFBZ0IsQ0FBQyxLQUFrQztRQUN0RCxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxJQUFJLGdCQUFnQjtRQUNuQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUM7SUFDckMsQ0FBQztJQWtERDs7OztPQUlHO0lBQ0gsbUJBQW1CLENBQUMsS0FBYTtRQUNoQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUN4RTthQUFNO1lBQ04sSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ3BFO0lBQ0YsQ0FBQztJQUVELFVBQVUsQ0FBQyxLQUFhO1FBQ3ZCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRCxtQkFBbUI7UUFDbEIsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO0lBQ3ZDLENBQUM7SUFFRCx3QkFBd0I7UUFDdkIsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDO0lBQzVDLENBQUM7SUFFRCxzQkFBc0IsQ0FBQyxHQUFHO1FBQ3pCLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUMsSUFBSSxLQUFLLEVBQUU7WUFDVixPQUFPLEtBQUssQ0FBQyxZQUFZLENBQUM7U0FDMUI7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNkLENBQUM7SUFFRCxtQkFBbUIsQ0FBQyxHQUFHO1FBQ3RCLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2QyxDQUFDOzs7WUF2S0QsU0FBUyxTQUFDO2dCQUNWLCtDQUErQztnQkFDL0MsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXFEVDthQUNEOzs7O1lBN0RRLElBQUk7OztvQkErRFgsS0FBSztpQ0FLTCxLQUFLO29DQUVMLEtBQUs7K0JBU0wsS0FBSztrQ0FZTCxLQUFLO21CQUtMLEtBQUs7bUNBWUwsS0FBSzt1QkFFTCxLQUFLO3dCQU9MLE1BQU07MEJBT04sTUFBTTt1QkFLTixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0Q29tcG9uZW50LFxuXHRJbnB1dCxcblx0RXZlbnRFbWl0dGVyLFxuXHRPdXRwdXRcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IFRhYmxlTW9kZWwgfSBmcm9tIFwiLi4vdGFibGUtbW9kZWwuY2xhc3NcIjtcbmltcG9ydCB7IEkxOG4sIE92ZXJyaWRhYmxlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4blwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBUYWJsZVJvd1NpemUgfSBmcm9tIFwiLi4vdGFibGUudHlwZXNcIjtcblxuQENvbXBvbmVudCh7XG5cdC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogY29tcG9uZW50LXNlbGVjdG9yXG5cdHNlbGVjdG9yOiBcIltpYm1UYWJsZUJvZHldXCIsXG5cdHRlbXBsYXRlOiBgXG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIm1vZGVsXCI+XG5cdFx0XHQ8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCByb3cgb2YgbW9kZWwuZGF0YTsgbGV0IGkgPSBpbmRleFwiPlxuXHRcdFx0XHQ8dHJcblx0XHRcdFx0XHRpYm1UYWJsZVJvd1xuXHRcdFx0XHRcdFttb2RlbF09XCJtb2RlbFwiXG5cdFx0XHRcdFx0W3Jvd109XCJyb3dcIlxuXHRcdFx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0XHRcdFtzZWxlY3RlZF09XCJtb2RlbC5pc1Jvd1NlbGVjdGVkKGkpXCJcblx0XHRcdFx0XHRbZXhwYW5kYWJsZV09XCJtb2RlbC5pc1Jvd0V4cGFuZGFibGUoaSlcIlxuXHRcdFx0XHRcdFtleHBhbmRlZF09XCJtb2RlbC5pc1Jvd0V4cGFuZGVkKGkpXCJcblx0XHRcdFx0XHRbY2hlY2tib3hMYWJlbF09XCJnZXRDaGVja2JveFJvd0xhYmVsKClcIlxuXHRcdFx0XHRcdFtleHBhbmRCdXR0b25BcmlhTGFiZWxdPVwiZ2V0RXhwYW5kQnV0dG9uQXJpYUxhYmVsKClcIlxuXHRcdFx0XHRcdFtzaG93U2VsZWN0aW9uQ29sdW1uXT1cInNob3dTZWxlY3Rpb25Db2x1bW5cIlxuXHRcdFx0XHRcdFtlbmFibGVTaW5nbGVTZWxlY3RdPVwiZW5hYmxlU2luZ2xlU2VsZWN0XCJcblx0XHRcdFx0XHRbc2tlbGV0b25dPVwic2tlbGV0b25cIlxuXHRcdFx0XHRcdChzZWxlY3RSb3cpPVwib25Sb3dDaGVja2JveENoYW5nZShpKVwiXG5cdFx0XHRcdFx0KGRlc2VsZWN0Um93KT1cIm9uUm93Q2hlY2tib3hDaGFuZ2UoaSlcIlxuXHRcdFx0XHRcdChleHBhbmRSb3cpPVwibW9kZWwuZXhwYW5kUm93KGksICFtb2RlbC5pc1Jvd0V4cGFuZGVkKGkpKVwiXG5cdFx0XHRcdFx0KHJvd0NsaWNrKT1cIm9uUm93Q2xpY2soaSlcIlxuXHRcdFx0XHRcdCpuZ0lmPVwiIW1vZGVsLmlzUm93RmlsdGVyZWQoaSlcIlxuXHRcdFx0XHRcdFtjbGFzc109XCIobW9kZWwucm93c0NsYXNzW2ldID8gbW9kZWwucm93c0NsYXNzW2ldIDogbnVsbClcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdCd0Ym9keV9yb3ctLXN1Y2Nlc3MnOiAhbW9kZWwuaXNSb3dTZWxlY3RlZChpKSAmJiBtb2RlbC5nZXRSb3dDb250ZXh0KGkpID09PSAnc3VjY2VzcycsXG5cdFx0XHRcdFx0XHQndGJvZHlfcm93LS13YXJuaW5nJzogIW1vZGVsLmlzUm93U2VsZWN0ZWQoaSkgJiYgbW9kZWwuZ2V0Um93Q29udGV4dChpKSA9PT0gJ3dhcm5pbmcnLFxuXHRcdFx0XHRcdFx0J3Rib2R5X3Jvdy0taW5mbyc6ICFtb2RlbC5pc1Jvd1NlbGVjdGVkKGkpICYmIG1vZGVsLmdldFJvd0NvbnRleHQoaSkgPT09ICdpbmZvJyxcblx0XHRcdFx0XHRcdCd0Ym9keV9yb3ctLWVycm9yJzogIW1vZGVsLmlzUm93U2VsZWN0ZWQoaSkgJiYgbW9kZWwuZ2V0Um93Q29udGV4dChpKSA9PT0gJ2Vycm9yJ1xuXHRcdFx0XHRcdH1cIj5cblx0XHRcdFx0PC90cj5cblx0XHRcdFx0PHRyXG5cdFx0XHRcdFx0Km5nSWY9XCJtb2RlbC5pc1Jvd0V4cGFuZGFibGUoaSkgJiYgIXNob3VsZEV4cGFuZEFzVGFibGUocm93KSAmJiAhbW9kZWwuaXNSb3dGaWx0ZXJlZChpKVwiXG5cdFx0XHRcdFx0aWJtVGFibGVFeHBhbmRlZFJvd1xuXHRcdFx0XHRcdGlibUV4cGFuZGVkUm93SG92ZXJcblx0XHRcdFx0XHRbcm93XT1cInJvd1wiXG5cdFx0XHRcdFx0W2V4cGFuZGVkXT1cIm1vZGVsLmlzUm93RXhwYW5kZWQoaSlcIlxuXHRcdFx0XHRcdFtza2VsZXRvbl09XCJza2VsZXRvblwiPlxuXHRcdFx0XHQ8L3RyPlxuXHRcdFx0XHQ8bmctY29udGFpbmVyXG5cdFx0XHRcdFx0Km5nSWY9XCJtb2RlbC5pc1Jvd0V4cGFuZGFibGUoaSkgJiYgc2hvdWxkRXhwYW5kQXNUYWJsZShyb3cpICYmIG1vZGVsLmlzUm93RXhwYW5kZWQoaSkgJiYgIW1vZGVsLmlzUm93RmlsdGVyZWQoaSlcIj5cblx0XHRcdFx0XHQ8dHJcblx0XHRcdFx0XHRcdCpuZ0Zvcj1cImxldCBleHBhbmRlZERhdGFSb3cgb2YgZmlyc3RFeHBhbmRlZERhdGFJblJvdyhyb3cpXCJcblx0XHRcdFx0XHRcdGlibVRhYmxlUm93XG5cdFx0XHRcdFx0XHRbbW9kZWxdPVwibW9kZWxcIlxuXHRcdFx0XHRcdFx0W3Nob3dTZWxlY3Rpb25Db2x1bW5DaGVja2JveF09XCJmYWxzZVwiXG5cdFx0XHRcdFx0XHRbc2hvd1NlbGVjdGlvbkNvbHVtbl09XCJzaG93U2VsZWN0aW9uQ29sdW1uXCJcblx0XHRcdFx0XHRcdFtyb3ddPVwiZXhwYW5kZWREYXRhUm93XCJcblx0XHRcdFx0XHRcdFtzaXplXT1cInNpemVcIlxuXHRcdFx0XHRcdFx0W3NrZWxldG9uXT1cInNrZWxldG9uXCI+XG5cdFx0XHRcdFx0PC90cj5cblx0XHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHQ8L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cdGBcbn0pXG5leHBvcnQgY2xhc3MgVGFibGVCb2R5IHtcblx0QElucHV0KCkgbW9kZWw6IFRhYmxlTW9kZWw7XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHdoZXRoZXIgdG8gZW5hYmxlIG11bHRpcGxlIG9yIHNpbmdsZSByb3cgc2VsZWN0aW9uLlxuXHQgKi9cblx0QElucHV0KCkgZW5hYmxlU2luZ2xlU2VsZWN0ID0gZmFsc2U7XG5cblx0QElucHV0KClcblx0c2V0IGV4cGFuZEJ1dHRvbkFyaWFMYWJlbCh2YWx1ZTogc3RyaW5nIHwgT2JzZXJ2YWJsZTxzdHJpbmc+KSB7XG5cdFx0dGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBleHBhbmRCdXR0b25BcmlhTGFiZWwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbC52YWx1ZTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBjaGVja2JveFJvd0xhYmVsKHZhbHVlOiBzdHJpbmcgfCBPYnNlcnZhYmxlPHN0cmluZz4pIHtcblx0XHR0aGlzLl9jaGVja2JveFJvd0xhYmVsLm92ZXJyaWRlKHZhbHVlKTtcblx0fVxuXG5cdGdldCBjaGVja2JveFJvd0xhYmVsKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveFJvd0xhYmVsLnZhbHVlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnRyb2xzIHdoZXRoZXIgdG8gc2hvdyB0aGUgc2VsZWN0aW9uIGNoZWNrYm94ZXMgY29sdW1uIG9yIG5vdC5cblx0ICovXG5cdEBJbnB1dCgpIHNob3dTZWxlY3Rpb25Db2x1bW4gPSB0cnVlO1xuXG5cdC8qKlxuXHQgKiBTaXplIG9mIHRoZSB0YWJsZSByb3dzLlxuXHQgKi9cblx0QElucHV0KCkgc2l6ZTogVGFibGVSb3dTaXplID0gXCJtZFwiO1xuXG5cdC8qKlxuXHQgKiBVc2VkIHRvIHBvcHVsYXRlIHRoZSByb3cgc2VsZWN0aW9uIGNoZWNrYm94IGxhYmVsIHdpdGggYSB1c2VmdWwgdmFsdWUgaWYgc2V0LlxuXHQgKlxuXHQgKiBFeGFtcGxlOlxuXHQgKiBgYGBcblx0ICogPGlibS10YWJsZSBbc2VsZWN0aW9uTGFiZWxDb2x1bW5dPVwiMFwiPjwvaWJtLXRhYmxlPlxuXHQgKiA8IS0tIHJlc3VsdHMgaW4gYXJpYS1sYWJlbD1cIlNlbGVjdCBmaXJzdCBjb2x1bW4gdmFsdWVcIlxuXHQgKiAod2hlcmUgXCJmaXJzdCBjb2x1bW4gdmFsdWVcIiBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGNvbHVtbiBpbiB0aGUgcm93IC0tPlxuXHQgKiBgYGBcblx0ICovXG5cdEBJbnB1dCgpIHNlbGVjdGlvbkxhYmVsQ29sdW1uOiBudW1iZXI7XG5cblx0QElucHV0KCkgc2tlbGV0b24gPSBmYWxzZTtcblxuXHQvKipcblx0ICogRW1pdHMgaWYgYSBzaW5nbGUgcm93IGlzIHNlbGVjdGVkLlxuXHQgKlxuXHQgKiBAcGFyYW0gKHttb2RlbDogdGhpcy5tb2RlbCwgc2VsZWN0ZWRSb3dJbmRleDogaW5kZXh9KVxuXHQgKi9cblx0QE91dHB1dCgpIHNlbGVjdFJvdyA9IG5ldyBFdmVudEVtaXR0ZXI8T2JqZWN0PigpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBpZiBhIHNpbmdsZSByb3cgaXMgZGVzZWxlY3RlZC5cblx0ICpcblx0ICogQHBhcmFtICh7bW9kZWw6IHRoaXMubW9kZWwsIGRlc2VsZWN0ZWRSb3dJbmRleDogaW5kZXh9KVxuXHQgKi9cblx0QE91dHB1dCgpIGRlc2VsZWN0Um93ID0gbmV3IEV2ZW50RW1pdHRlcjxPYmplY3Q+KCk7XG5cblx0LyoqXG5cdCAqIEVtaXRzIGlmIGEgcm93IGl0ZW0gZXhjbHVkaW5nIGV4cGFuZEJ1dHRvbnMsIGNoZWNrYm94ZXMsIG9yIHJhZGlvcyBpcyBjbGlja2VkLlxuXHQgKi9cblx0QE91dHB1dCgpIHJvd0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cblx0cHJvdGVjdGVkIF9jaGVja2JveFJvd0xhYmVsID0gdGhpcy5pMThuLmdldE92ZXJyaWRhYmxlKFwiVEFCTEUuQ0hFQ0tCT1hfUk9XXCIpO1xuXHRwcm90ZWN0ZWQgX2V4cGFuZEJ1dHRvbkFyaWFMYWJlbCA9IHRoaXMuaTE4bi5nZXRPdmVycmlkYWJsZShcIlRBQkxFLkVYUEFORF9CVVRUT05cIik7XG5cblx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGkxOG46IEkxOG4pIHsgfVxuXG5cdC8qKlxuXHQgKiBUcmlnZ2VyZWQgd2hlbiBhIHNpbmdsZSByb3cgaXMgY2xpY2tlZC5cblx0ICogVXBkYXRlcyB0aGUgaGVhZGVyIGNoZWNrYm94IHN0YXRlLlxuXHQgKiBFbWl0cyB0aGUgYHNlbGVjdFJvd2Agb3IgYGRlc2VsZWN0Um93YCBldmVudC5cblx0ICovXG5cdG9uUm93Q2hlY2tib3hDaGFuZ2UoaW5kZXg6IG51bWJlcikge1xuXHRcdGlmICh0aGlzLm1vZGVsLmlzUm93U2VsZWN0ZWQoaW5kZXgpKSB7XG5cdFx0XHR0aGlzLmRlc2VsZWN0Um93LmVtaXQoeyBtb2RlbDogdGhpcy5tb2RlbCwgZGVzZWxlY3RlZFJvd0luZGV4OiBpbmRleCB9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZWxlY3RSb3cuZW1pdCh7IG1vZGVsOiB0aGlzLm1vZGVsLCBzZWxlY3RlZFJvd0luZGV4OiBpbmRleCB9KTtcblx0XHR9XG5cdH1cblxuXHRvblJvd0NsaWNrKGluZGV4OiBudW1iZXIpIHtcblx0XHR0aGlzLnJvd0NsaWNrLmVtaXQoaW5kZXgpO1xuXHR9XG5cblx0Z2V0Q2hlY2tib3hSb3dMYWJlbCgpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuXHRcdHJldHVybiB0aGlzLl9jaGVja2JveFJvd0xhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRnZXRFeHBhbmRCdXR0b25BcmlhTGFiZWwoKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcblx0XHRyZXR1cm4gdGhpcy5fZXhwYW5kQnV0dG9uQXJpYUxhYmVsLnN1YmplY3Q7XG5cdH1cblxuXHRmaXJzdEV4cGFuZGVkRGF0YUluUm93KHJvdykge1xuXHRcdGNvbnN0IGZvdW5kID0gcm93LmZpbmQoZCA9PiBkLmV4cGFuZGVkRGF0YSk7XG5cdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRyZXR1cm4gZm91bmQuZXhwYW5kZWREYXRhO1xuXHRcdH1cblx0XHRyZXR1cm4gZm91bmQ7XG5cdH1cblxuXHRzaG91bGRFeHBhbmRBc1RhYmxlKHJvdykge1xuXHRcdHJldHVybiByb3cuc29tZShkID0+IGQuZXhwYW5kQXNUYWJsZSk7XG5cdH1cbn1cbiJdfQ==