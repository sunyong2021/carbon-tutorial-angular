/**
 *
 * carbon-angular v0.0.0 | select.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import { Component, ElementRef, Input, Output, HostListener, EventEmitter, TemplateRef, ViewChild } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
/**
 * `ibm-select` provides a styled `select` component.
 *
 * [See demo](../../?path=/story/select--basic)
 *
 * Example:
 *
 * ```
 * <ibm-select [(ngModel)]="model">
 * 	<option value="default" disabled selected hidden>Choose an option</option>
 * 	<option value="option1">Option 1</option>
 *	<option value="option2">Option 2</option>
 * 	<option value="option3">Option 3</option>
 * </ibm-select>
 *	```
 *
 * <example-url>../../iframe.html?id=select--basic</example-url>
 */
export class Select {
    constructor() {
        /**
         * `inline` or `default` select displays
         */
        this.display = "default";
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        /**
         * Sets the unique ID. Defaults to `select-${total count of selects instantiated}`
         */
        this.id = `select-${Select.selectCount++}`;
        /**
         * Number input field render size
         */
        this.size = "md";
        /**
         * Set to true to disable component.
         */
        this.disabled = false;
        /**
         * Set to true for a loading select.
         */
        this.skeleton = false;
        /**
         * Set to `true` for an invalid select component.
         */
        this.invalid = false;
        /**
         * `light` or `dark` select theme
         */
        this.theme = "dark";
        this.valueChange = new EventEmitter();
        /**
         * placeholder declarations. Replaced by the functions provided to `registerOnChange` and `registerOnTouched`
         */
        this.onChangeHandler = (_) => { };
        this.onTouchedHandler = () => { };
    }
    set value(v) {
        this._value = v;
        if (this.select) {
            this.select.nativeElement.value = this._value;
        }
    }
    get value() {
        return this._value;
    }
    ngAfterViewInit() {
        if (this.value !== undefined &&
            this.value !== null &&
            this.select &&
            this.select.nativeElement.value !== this.value) {
            this.select.nativeElement.value = this.value;
        }
    }
    /**
     * Receives a value from the model.
     */
    writeValue(obj) {
        this.value = obj;
    }
    /**
     * Registers a listener that notifies the model when the control updates
     */
    registerOnChange(fn) {
        this.onChangeHandler = fn;
    }
    /**
     * Registers a listener that notifies the model when the control is blurred
     */
    registerOnTouched(fn) {
        this.onTouchedHandler = fn;
    }
    /**
     * Sets the disabled state through the model
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Handles the change event from the `select`.
     * Sends events to the change handler and emits a `selected` event.
     */
    onChange(event) {
        this.value = event.target.value;
        this.onChangeHandler(event.target.value);
        this.valueChange.emit(event.target.value);
    }
    /**
     * Listens for the host blurring, and notifies the model
     */
    focusOut() {
        this.onTouchedHandler();
    }
    isTemplate(value) {
        return value instanceof TemplateRef;
    }
}
/**
 * Tracks the total number of selects instantiated. Used to generate unique IDs
 */
Select.selectCount = 0;
Select.decorators = [
    { type: Component, args: [{
                selector: "ibm-select",
                template: `
		<div class="bx--form-item">
			<ng-template [ngIf]="skeleton">
				<div *ngIf="label" class="bx--label bx--skeleton"></div>
				<div class="bx--select bx--skeleton"></div>
			</ng-template>
			<div
				*ngIf="!skeleton"
				class="bx--select"
				[ngClass]="{
					'bx--select--inline': display === 'inline',
					'bx--select--light': theme === 'light',
					'bx--select--invalid': invalid,
					'bx--select--warning': warn,
					'bx--select--disabled': disabled
				}">
				<label *ngIf="label" [for]="id" class="bx--label">
					<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
					<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
				</label>
				<div *ngIf="helperText" class="bx--form__helper-text">
					<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
					<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
				</div>
				<div *ngIf="display === 'inline'; else noInline" class="bx--select-input--inline__wrapper">
					<ng-container *ngTemplateOutlet="noInline"></ng-container>
				</div>
			</div>
		</div>

		<!-- select element: dynamically projected based on 'display' variant -->
		<ng-template #noInline>
			<div class="bx--select-input__wrapper" [attr.data-invalid]="(invalid ? true : null)">
				<select
					#select
					[attr.id]="id"
					[attr.aria-label]="ariaLabel"
					[disabled]="disabled"
					(change)="onChange($event)"
					[attr.aria-invalid]="invalid ? 'true' : null"
					class="bx--select-input"
					[ngClass]="{
						'bx--select-input--xl': size === 'xl',
						'bx--select-input--sm': size === 'sm'
					}">
					<ng-content></ng-content>
				</select>
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					xmlns="http://www.w3.org/2000/svg"
					class="bx--select__arrow"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"></path>
				</svg>
				<svg
					*ngIf="!warn && invalid"
					ibmIcon="warning--filled"
					size="16"
					class="bx--select__invalid-icon">
				</svg>
				<svg
					*ngIf="!invalid && warn"
					ibmIcon="warning--alt--filled"
					size="16"
					class="bx--select__invalid-icon bx--select__invalid-icon--warning">
				</svg>
			</div>
			<div *ngIf="invalid && invalidText && !warn" role="alert" class="bx--form-requirement" aria-live="polite">
				<ng-container *ngIf="!isTemplate(invalidText)">{{invalidText}}</ng-container>
				<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
			</div>
			<div *ngIf="!invalid && warn" class="bx--form-requirement">
				<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
				<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
			</div>
		</ng-template>
	`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: Select,
                        multi: true
                    }
                ],
                styles: [`
		.bx--select--inline .bx--form__helper-text {
			order: 4;
		}

		.bx--select--inline:not(.bx--select--invalid) .bx--form__helper-text {
			margin-top: 0;
		}
	`]
            }] }
];
Select.propDecorators = {
    display: [{ type: Input }],
    label: [{ type: Input }],
    helperText: [{ type: Input }],
    invalidText: [{ type: Input }],
    warn: [{ type: Input }],
    warnText: [{ type: Input }],
    id: [{ type: Input }],
    size: [{ type: Input }],
    disabled: [{ type: Input }],
    skeleton: [{ type: Input }],
    invalid: [{ type: Input }],
    theme: [{ type: Input }],
    ariaLabel: [{ type: Input }],
    valueChange: [{ type: Output }],
    select: [{ type: ViewChild, args: ["select", { static: false },] }],
    value: [{ type: Input }],
    focusOut: [{ type: HostListener, args: ["focusout",] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvc2VsZWN0LyIsInNvdXJjZXMiOlsic2VsZWN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRU4sU0FBUyxFQUNULFVBQVUsRUFDVixLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixZQUFZLEVBQ1osV0FBVyxFQUNYLFNBQVMsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFekU7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBaUJHO0FBc0dILE1BQU0sT0FBTyxNQUFNO0lBckduQjtRQTJHQzs7V0FFRztRQUNNLFlBQU8sR0FBeUIsU0FBUyxDQUFDO1FBYW5EOztZQUVJO1FBQ0ssU0FBSSxHQUFHLEtBQUssQ0FBQztRQUt0Qjs7V0FFRztRQUNNLE9BQUUsR0FBRyxVQUFVLE1BQU0sQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO1FBQy9DOztXQUVHO1FBQ00sU0FBSSxHQUF1QixJQUFJLENBQUM7UUFDekM7O1dBRUc7UUFDTSxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQzFCOztXQUVHO1FBQ00sYUFBUSxHQUFHLEtBQUssQ0FBQztRQUMxQjs7V0FFRztRQUNNLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFFekI7O1dBRUc7UUFDTSxVQUFLLEdBQXFCLE1BQU0sQ0FBQztRQUdoQyxnQkFBVyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUErRTNDOztXQUVHO1FBQ08sb0JBQWUsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLHFCQUFnQixHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBL0VBLElBQWEsS0FBSyxDQUFDLENBQUM7UUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDaEIsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQzlDO0lBQ0YsQ0FBQztJQUVELElBQUksS0FBSztRQUNSLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNwQixDQUFDO0lBSUQsZUFBZTtRQUNkLElBQ0MsSUFBSSxDQUFDLEtBQUssS0FBSyxTQUFTO1lBQ3hCLElBQUksQ0FBQyxLQUFLLEtBQUssSUFBSTtZQUNuQixJQUFJLENBQUMsTUFBTTtZQUNYLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxFQUM3QztZQUNELElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1NBQzdDO0lBQ0YsQ0FBQztJQUVEOztPQUVHO0lBQ0gsVUFBVSxDQUFDLEdBQVE7UUFDbEIsSUFBSSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUM7SUFDbEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0JBQWdCLENBQUMsRUFBTztRQUN2QixJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQ7O09BRUc7SUFDSCxpQkFBaUIsQ0FBQyxFQUFPO1FBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZ0JBQWdCLENBQUMsVUFBbUI7UUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7SUFDNUIsQ0FBQztJQUVEOzs7T0FHRztJQUNILFFBQVEsQ0FBQyxLQUFLO1FBQ2IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNoQyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDekMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxDQUFDO0lBRUQ7O09BRUc7SUFFSCxRQUFRO1FBQ1AsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVNLFVBQVUsQ0FBQyxLQUFLO1FBQ3RCLE9BQU8sS0FBSyxZQUFZLFdBQVcsQ0FBQztJQUNyQyxDQUFDOztBQXJJRDs7R0FFRztBQUNJLGtCQUFXLEdBQUcsQ0FBQyxDQUFDOztZQXpHdkIsU0FBUyxTQUFDO2dCQUNWLFFBQVEsRUFBRSxZQUFZO2dCQUN0QixRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlGVDtnQkFVRCxTQUFTLEVBQUU7b0JBQ1Y7d0JBQ0MsT0FBTyxFQUFFLGlCQUFpQjt3QkFDMUIsV0FBVyxFQUFFLE1BQU07d0JBQ25CLEtBQUssRUFBRSxJQUFJO3FCQUNYO2lCQUNEO3lCQWZROzs7Ozs7OztFQVFSO2FBUUQ7OztzQkFVQyxLQUFLO29CQUlMLEtBQUs7eUJBSUwsS0FBSzswQkFJTCxLQUFLO21CQUlMLEtBQUs7dUJBSUwsS0FBSztpQkFJTCxLQUFLO21CQUlMLEtBQUs7dUJBSUwsS0FBSzt1QkFJTCxLQUFLO3NCQUlMLEtBQUs7b0JBS0wsS0FBSzt3QkFDTCxLQUFLOzBCQUVMLE1BQU07cUJBR04sU0FBUyxTQUFDLFFBQVEsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7b0JBRXJDLEtBQUs7dUJBaUVMLFlBQVksU0FBQyxVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0QWZ0ZXJWaWV3SW5pdCxcblx0Q29tcG9uZW50LFxuXHRFbGVtZW50UmVmLFxuXHRJbnB1dCxcblx0T3V0cHV0LFxuXHRIb3N0TGlzdGVuZXIsXG5cdEV2ZW50RW1pdHRlcixcblx0VGVtcGxhdGVSZWYsXG5cdFZpZXdDaGlsZFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XG5cbi8qKlxuICogYGlibS1zZWxlY3RgIHByb3ZpZGVzIGEgc3R5bGVkIGBzZWxlY3RgIGNvbXBvbmVudC5cbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9zZWxlY3QtLWJhc2ljKVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiA8aWJtLXNlbGVjdCBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiBcdDxvcHRpb24gdmFsdWU9XCJkZWZhdWx0XCIgZGlzYWJsZWQgc2VsZWN0ZWQgaGlkZGVuPkNob29zZSBhbiBvcHRpb248L29wdGlvbj5cbiAqIFx0PG9wdGlvbiB2YWx1ZT1cIm9wdGlvbjFcIj5PcHRpb24gMTwvb3B0aW9uPlxuICpcdDxvcHRpb24gdmFsdWU9XCJvcHRpb24yXCI+T3B0aW9uIDI8L29wdGlvbj5cbiAqIFx0PG9wdGlvbiB2YWx1ZT1cIm9wdGlvbjNcIj5PcHRpb24gMzwvb3B0aW9uPlxuICogPC9pYm0tc2VsZWN0PlxuICpcdGBgYFxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1zZWxlY3QtLWJhc2ljPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1zZWxlY3RcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGNsYXNzPVwiYngtLWZvcm0taXRlbVwiPlxuXHRcdFx0PG5nLXRlbXBsYXRlIFtuZ0lmXT1cInNrZWxldG9uXCI+XG5cdFx0XHRcdDxkaXYgKm5nSWY9XCJsYWJlbFwiIGNsYXNzPVwiYngtLWxhYmVsIGJ4LS1za2VsZXRvblwiPjwvZGl2PlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNlbGVjdCBieC0tc2tlbGV0b25cIj48L2Rpdj5cblx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8ZGl2XG5cdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uXCJcblx0XHRcdFx0Y2xhc3M9XCJieC0tc2VsZWN0XCJcblx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdCdieC0tc2VsZWN0LS1pbmxpbmUnOiBkaXNwbGF5ID09PSAnaW5saW5lJyxcblx0XHRcdFx0XHQnYngtLXNlbGVjdC0tbGlnaHQnOiB0aGVtZSA9PT0gJ2xpZ2h0Jyxcblx0XHRcdFx0XHQnYngtLXNlbGVjdC0taW52YWxpZCc6IGludmFsaWQsXG5cdFx0XHRcdFx0J2J4LS1zZWxlY3QtLXdhcm5pbmcnOiB3YXJuLFxuXHRcdFx0XHRcdCdieC0tc2VsZWN0LS1kaXNhYmxlZCc6IGRpc2FibGVkXG5cdFx0XHRcdH1cIj5cblx0XHRcdFx0PGxhYmVsICpuZ0lmPVwibGFiZWxcIiBbZm9yXT1cImlkXCIgY2xhc3M9XCJieC0tbGFiZWxcIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShsYWJlbClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFwiPjwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxkaXYgKm5nSWY9XCJoZWxwZXJUZXh0XCIgY2xhc3M9XCJieC0tZm9ybV9faGVscGVyLXRleHRcIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUoaGVscGVyVGV4dClcIj57e2hlbHBlclRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0XHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUoaGVscGVyVGV4dClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJoZWxwZXJUZXh0XCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDxkaXYgKm5nSWY9XCJkaXNwbGF5ID09PSAnaW5saW5lJzsgZWxzZSBub0lubGluZVwiIGNsYXNzPVwiYngtLXNlbGVjdC1pbnB1dC0taW5saW5lX193cmFwcGVyXCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vSW5saW5lXCI+PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cblx0XHQ8IS0tIHNlbGVjdCBlbGVtZW50OiBkeW5hbWljYWxseSBwcm9qZWN0ZWQgYmFzZWQgb24gJ2Rpc3BsYXknIHZhcmlhbnQgLS0+XG5cdFx0PG5nLXRlbXBsYXRlICNub0lubGluZT5cblx0XHRcdDxkaXYgY2xhc3M9XCJieC0tc2VsZWN0LWlucHV0X193cmFwcGVyXCIgW2F0dHIuZGF0YS1pbnZhbGlkXT1cIihpbnZhbGlkID8gdHJ1ZSA6IG51bGwpXCI+XG5cdFx0XHRcdDxzZWxlY3Rcblx0XHRcdFx0XHQjc2VsZWN0XG5cdFx0XHRcdFx0W2F0dHIuaWRdPVwiaWRcIlxuXHRcdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcblx0XHRcdFx0XHRbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0XHRcdChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG5cdFx0XHRcdFx0W2F0dHIuYXJpYS1pbnZhbGlkXT1cImludmFsaWQgPyAndHJ1ZScgOiBudWxsXCJcblx0XHRcdFx0XHRjbGFzcz1cImJ4LS1zZWxlY3QtaW5wdXRcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHRcdCdieC0tc2VsZWN0LWlucHV0LS14bCc6IHNpemUgPT09ICd4bCcsXG5cdFx0XHRcdFx0XHQnYngtLXNlbGVjdC1pbnB1dC0tc20nOiBzaXplID09PSAnc20nXG5cdFx0XHRcdFx0fVwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblx0XHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRmb2N1c2FibGU9XCJmYWxzZVwiXG5cdFx0XHRcdFx0cHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuXHRcdFx0XHRcdHN0eWxlPVwid2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcIlxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdGNsYXNzPVwiYngtLXNlbGVjdF9fYXJyb3dcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTggMTFMMyA2IDMuNyA1LjMgOCA5LjYgMTIuMyA1LjMgMTMgNnpcIj48L3BhdGg+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0Km5nSWY9XCIhd2FybiAmJiBpbnZhbGlkXCJcblx0XHRcdFx0XHRpYm1JY29uPVwid2FybmluZy0tZmlsbGVkXCJcblx0XHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRcdGNsYXNzPVwiYngtLXNlbGVjdF9faW52YWxpZC1pY29uXCI+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHQ8c3ZnXG5cdFx0XHRcdFx0Km5nSWY9XCIhaW52YWxpZCAmJiB3YXJuXCJcblx0XHRcdFx0XHRpYm1JY29uPVwid2FybmluZy0tYWx0LS1maWxsZWRcIlxuXHRcdFx0XHRcdHNpemU9XCIxNlwiXG5cdFx0XHRcdFx0Y2xhc3M9XCJieC0tc2VsZWN0X19pbnZhbGlkLWljb24gYngtLXNlbGVjdF9faW52YWxpZC1pY29uLS13YXJuaW5nXCI+XG5cdFx0XHRcdDwvc3ZnPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2ICpuZ0lmPVwiaW52YWxpZCAmJiBpbnZhbGlkVGV4dCAmJiAhd2FyblwiIHJvbGU9XCJhbGVydFwiIGNsYXNzPVwiYngtLWZvcm0tcmVxdWlyZW1lbnRcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIj5cblx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGludmFsaWRUZXh0KVwiPnt7aW52YWxpZFRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGludmFsaWRUZXh0KVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImludmFsaWRUZXh0XCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiAqbmdJZj1cIiFpbnZhbGlkICYmIHdhcm5cIiBjbGFzcz1cImJ4LS1mb3JtLXJlcXVpcmVtZW50XCI+XG5cdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCIhaXNUZW1wbGF0ZSh3YXJuVGV4dClcIj57e3dhcm5UZXh0fX08L25nLWNvbnRhaW5lcj5cblx0XHRcdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZSh3YXJuVGV4dClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJ3YXJuVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L25nLXRlbXBsYXRlPlxuXHRgLFxuXHRzdHlsZXM6IFtgXG5cdFx0LmJ4LS1zZWxlY3QtLWlubGluZSAuYngtLWZvcm1fX2hlbHBlci10ZXh0IHtcblx0XHRcdG9yZGVyOiA0O1xuXHRcdH1cblxuXHRcdC5ieC0tc2VsZWN0LS1pbmxpbmU6bm90KC5ieC0tc2VsZWN0LS1pbnZhbGlkKSAuYngtLWZvcm1fX2hlbHBlci10ZXh0IHtcblx0XHRcdG1hcmdpbi10b3A6IDA7XG5cdFx0fVxuXHRgXSxcblx0cHJvdmlkZXJzOiBbXG5cdFx0e1xuXHRcdFx0cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG5cdFx0XHR1c2VFeGlzdGluZzogU2VsZWN0LFxuXHRcdFx0bXVsdGk6IHRydWVcblx0XHR9XG5cdF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEFmdGVyVmlld0luaXQge1xuXHQvKipcblx0ICogVHJhY2tzIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VsZWN0cyBpbnN0YW50aWF0ZWQuIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEc1xuXHQgKi9cblx0c3RhdGljIHNlbGVjdENvdW50ID0gMDtcblxuXHQvKipcblx0ICogYGlubGluZWAgb3IgYGRlZmF1bHRgIHNlbGVjdCBkaXNwbGF5c1xuXHQgKi9cblx0QElucHV0KCkgZGlzcGxheTogXCJpbmxpbmVcIiB8IFwiZGVmYXVsdFwiID0gXCJkZWZhdWx0XCI7XG5cdC8qKlxuXHQgKiBMYWJlbCBmb3IgdGhlIHNlbGVjdC4gQXBwZWFycyBhYm92ZSB0aGUgaW5wdXQuXG5cdCAqL1xuXHRASW5wdXQoKSBsYWJlbDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55Pjtcblx0LyoqXG5cdCAqIE9wdGlvbmFsIGhlbHBlciB0ZXh0IHRoYXQgYXBwZWFycyB1bmRlciB0aGUgbGFiZWwuXG5cdCAqL1xuXHRASW5wdXQoKSBoZWxwZXJUZXh0OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKipcblx0ICogU2V0cyB0aGUgaW52YWxpZCB0ZXh0LlxuXHQgKi9cblx0QElucHV0KCkgaW52YWxpZFRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgd2FybmluZyAoY29udGVudHMgc2V0IGJ5IHdhcm5pbmdUZXh0KVxuXHQgICovXG5cdEBJbnB1dCgpIHdhcm4gPSBmYWxzZTtcblx0LyoqXG5cdCAqIFNldHMgdGhlIHdhcm5pbmcgdGV4dFxuXHQgKi9cblx0QElucHV0KCkgd2FyblRleHQ6IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB1bmlxdWUgSUQuIERlZmF1bHRzIHRvIGBzZWxlY3QtJHt0b3RhbCBjb3VudCBvZiBzZWxlY3RzIGluc3RhbnRpYXRlZH1gXG5cdCAqL1xuXHRASW5wdXQoKSBpZCA9IGBzZWxlY3QtJHtTZWxlY3Quc2VsZWN0Q291bnQrK31gO1xuXHQvKipcblx0ICogTnVtYmVyIGlucHV0IGZpZWxkIHJlbmRlciBzaXplXG5cdCAqL1xuXHRASW5wdXQoKSBzaXplOiBcInNtXCIgfCBcIm1kXCIgfCBcInhsXCIgPSBcIm1kXCI7XG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGNvbXBvbmVudC5cblx0ICovXG5cdEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gdHJ1ZSBmb3IgYSBsb2FkaW5nIHNlbGVjdC5cblx0ICovXG5cdEBJbnB1dCgpIHNrZWxldG9uID0gZmFsc2U7XG5cdC8qKlxuXHQgKiBTZXQgdG8gYHRydWVgIGZvciBhbiBpbnZhbGlkIHNlbGVjdCBjb21wb25lbnQuXG5cdCAqL1xuXHRASW5wdXQoKSBpbnZhbGlkID0gZmFsc2U7XG5cblx0LyoqXG5cdCAqIGBsaWdodGAgb3IgYGRhcmtgIHNlbGVjdCB0aGVtZVxuXHQgKi9cblx0QElucHV0KCkgdGhlbWU6IFwibGlnaHRcIiB8IFwiZGFya1wiID0gXCJkYXJrXCI7XG5cdEBJbnB1dCgpIGFyaWFMYWJlbDogc3RyaW5nO1xuXG5cdEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXHQvLyBAdHMtaWdub3JlXG5cdEBWaWV3Q2hpbGQoXCJzZWxlY3RcIiwgeyBzdGF0aWM6IGZhbHNlIH0pIHNlbGVjdDogRWxlbWVudFJlZjtcblxuXHRASW5wdXQoKSBzZXQgdmFsdWUodikge1xuXHRcdHRoaXMuX3ZhbHVlID0gdjtcblx0XHRpZiAodGhpcy5zZWxlY3QpIHtcblx0XHRcdHRoaXMuc2VsZWN0Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSB0aGlzLl92YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRnZXQgdmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlO1xuXHR9XG5cblx0cHJvdGVjdGVkIF92YWx1ZTtcblxuXHRuZ0FmdGVyVmlld0luaXQoKSB7XG5cdFx0aWYgKFxuXHRcdFx0dGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmXG5cdFx0XHR0aGlzLnZhbHVlICE9PSBudWxsICYmXG5cdFx0XHR0aGlzLnNlbGVjdCAmJlxuXHRcdFx0dGhpcy5zZWxlY3QubmF0aXZlRWxlbWVudC52YWx1ZSAhPT0gdGhpcy52YWx1ZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5zZWxlY3QubmF0aXZlRWxlbWVudC52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJlY2VpdmVzIGEgdmFsdWUgZnJvbSB0aGUgbW9kZWwuXG5cdCAqL1xuXHR3cml0ZVZhbHVlKG9iajogYW55KSB7XG5cdFx0dGhpcy52YWx1ZSA9IG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IG5vdGlmaWVzIHRoZSBtb2RlbCB3aGVuIHRoZSBjb250cm9sIHVwZGF0ZXNcblx0ICovXG5cdHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xuXHRcdHRoaXMub25DaGFuZ2VIYW5kbGVyID0gZm47XG5cdH1cblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCBub3RpZmllcyB0aGUgbW9kZWwgd2hlbiB0aGUgY29udHJvbCBpcyBibHVycmVkXG5cdCAqL1xuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWRIYW5kbGVyID0gZm47XG5cdH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgZGlzYWJsZWQgc3RhdGUgdGhyb3VnaCB0aGUgbW9kZWxcblx0ICovXG5cdHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbikge1xuXHRcdHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgdGhlIGNoYW5nZSBldmVudCBmcm9tIHRoZSBgc2VsZWN0YC5cblx0ICogU2VuZHMgZXZlbnRzIHRvIHRoZSBjaGFuZ2UgaGFuZGxlciBhbmQgZW1pdHMgYSBgc2VsZWN0ZWRgIGV2ZW50LlxuXHQgKi9cblx0b25DaGFuZ2UoZXZlbnQpIHtcblx0XHR0aGlzLnZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuXHRcdHRoaXMub25DaGFuZ2VIYW5kbGVyKGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cdFx0dGhpcy52YWx1ZUNoYW5nZS5lbWl0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVucyBmb3IgdGhlIGhvc3QgYmx1cnJpbmcsIGFuZCBub3RpZmllcyB0aGUgbW9kZWxcblx0ICovXG5cdEBIb3N0TGlzdGVuZXIoXCJmb2N1c291dFwiKVxuXHRmb2N1c091dCgpIHtcblx0XHR0aGlzLm9uVG91Y2hlZEhhbmRsZXIoKTtcblx0fVxuXG5cdHB1YmxpYyBpc1RlbXBsYXRlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG5cdH1cblxuXHQvKipcblx0ICogcGxhY2Vob2xkZXIgZGVjbGFyYXRpb25zLiBSZXBsYWNlZCBieSB0aGUgZnVuY3Rpb25zIHByb3ZpZGVkIHRvIGByZWdpc3Rlck9uQ2hhbmdlYCBhbmQgYHJlZ2lzdGVyT25Ub3VjaGVkYFxuXHQgKi9cblx0cHJvdGVjdGVkIG9uQ2hhbmdlSGFuZGxlciA9IChfOiBhbnkpID0+IHsgfTtcblx0cHJvdGVjdGVkIG9uVG91Y2hlZEhhbmRsZXIgPSAoKSA9PiB7IH07XG59XG4iXX0=