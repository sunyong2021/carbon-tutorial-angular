/**
 *
 * carbon-angular v0.0.0 | slider.component.js
 *
 * Copyright 2014, 2021 IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


import * as tslib_1 from "tslib";
import { Component, HostBinding, Input, Output, EventEmitter, ViewChild, ElementRef, TemplateRef, ViewChildren, QueryList } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { EventService } from "carbon-components-angular/utils";
/**
 * Used to select from ranges of values. [See here](https://www.carbondesignsystem.com/components/slider/usage) for usage information.
 *
 * [See demo](../../?path=/story/slider--advanced)
 *
 * The simplest possible slider usage looks something like:
 * ```html
 * <ibm-slider></ibm-slider>
 * ```
 *
 * That will render a slider without labels or alternative value input. Labels can be provided by
 * elements with `[minLabel]` and `[maxLabel]` attributes, and an `input` (may use the `ibmInput` directive) can be supplied
 * for use as an alternative value field.
 *
 * ex:
 * ```html
 * <!-- full example -->
 * <ibm-slider>
 *		<span minLabel>0GB</span>
 *		<span maxLabel>100GB</span>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just an input -->
 * <ibm-slider>
 *		<input/>
 *	</ibm-slider>
 * <!-- with just one label -->
 * <ibm-slider>
 *		<span maxLabel>Maximum</span>
 *	</ibm-slider>
 * ```
 *
 * Slider supports `NgModel` by default, as well as two way binding to the `value` input.
 *
 * <example-url>../../iframe.html?id=slider--advanced</example-url>
 */
var Slider = /** @class */ (function () {
    function Slider(elementRef, eventService) {
        this.elementRef = elementRef;
        this.eventService = eventService;
        /** The interval for our range */
        this.step = 1;
        /** Base ID for the slider. The min and max labels get IDs `${this.id}-bottom-range` and `${this.id}-top-range` respectively */
        this.id = "slider-" + Slider.count++;
        /** Value used to "multiply" the `step` when using arrow keys to select values */
        this.shiftMultiplier = 4;
        /** Set to `true` for a loading slider */
        this.skeleton = false;
        /** Set to `true` for a slider without arrow key interactions. */
        this.disableArrowKeys = false;
        /** Emits every time a new value is selected */
        this.valueChange = new EventEmitter();
        this.hostClass = true;
        this.labelId = this.id + "-label";
        this.bottomRangeId = this.id + "-bottom-range";
        this.topRangeId = this.id + "-top-range";
        this.fractionComplete = 0;
        this.isMouseDown = false;
        this._min = 0;
        this._max = 100;
        this._value = [this.min];
        this._previousValue = [this.min];
        this._disabled = false;
        this._focusedThumbIndex = 0;
        /** Send changes back to the model */
        this.propagateChange = function (_) { };
        /** Callback to notify the model when our input has been touched */
        this.onTouched = function () { };
    }
    Object.defineProperty(Slider.prototype, "min", {
        get: function () {
            return this._min;
        },
        /** The lower bound of our range */
        set: function (v) {
            if (!v) {
                return;
            }
            this._min = v;
            // force the component to update
            this.value = this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "max", {
        get: function () {
            return this._max;
        },
        /** The upper bound of our range */
        set: function (v) {
            if (!v) {
                return;
            }
            this._max = v;
            // force the component to update
            this.value = this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "value", {
        get: function () {
            if (this.isRange()) {
                return this._value;
            }
            return this._value[0];
        },
        /** Set the initial value. Available for two way binding */
        set: function (v) {
            var _this = this;
            if (!v) {
                v = [this.min];
            }
            if (typeof v === "number" || typeof v === "string") {
                v = [Number(v)];
            }
            if (v[0] < this.min) {
                v[0] = this.min;
            }
            if (v[0] > this.max) {
                v[0] = this.max;
            }
            if (this.isRange()) {
                if (this._previousValue[0] !== v[0]) { // left moved
                    if (v[0] > v[1] - this.step) {
                        // stop the left handle if surpassing the right one
                        v[0] = v[1] - this.step;
                    }
                    else if (v[0] > this.max) {
                        v[0] = this.max;
                    }
                    else if (v[0] < this.min) {
                        v[0] = this.min;
                    }
                }
                if (this._previousValue[1] !== v[1]) { // right moved
                    if (v[1] > this.max) {
                        v[1] = this.max;
                    }
                    else if (v[1] < this._value[0] + this.step) {
                        // stop the right handle if surpassing the left one
                        v[1] = this._value[0] + this.step;
                    }
                    else if (v[1] < this.min) {
                        v[1] = this.min;
                    }
                }
            }
            this._previousValue = tslib_1.__spread(this._value); // store a copy, enable detection which handle moved
            this._value = tslib_1.__spread(v); // triggers change detection when ngModel value is an array (for range)
            if (this.isRange() && this.filledTrack) {
                this.updateTrackRangeWidth();
            }
            else if (this.filledTrack) {
                this.filledTrack.nativeElement.style.transform = "translate(0%, -50%) " + this.scaleX(this.getFractionComplete(v[0]));
            }
            if (this.inputs && this.inputs.length) {
                this.inputs.forEach(function (input, index) {
                    input.value = _this._value[index].toString();
                });
            }
            var valueToEmit = this.isRange() ? v : v[0];
            this.propagateChange(valueToEmit);
            this.valueChange.emit(valueToEmit);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slider.prototype, "disabled", {
        get: function () {
            return this._disabled;
        },
        /** Disables the range visually and functionally */
        set: function (v) {
            this._disabled = v;
            // for some reason `this.input` never exists here, so we have to query for it here too
            var inputs = this.getInputs();
            if (inputs && inputs.length > 0) {
                inputs.forEach(function (input) { return input.disabled = v; });
            }
        },
        enumerable: true,
        configurable: true
    });
    Slider.prototype.ngAfterViewInit = function () {
        var _this = this;
        // bind mousemove and mouseup to the document so we don't have issues tracking the mouse
        this.eventService.onDocument("mousemove", this.onMouseMove.bind(this));
        this.eventService.onDocument("mouseup", this.onMouseUp.bind(this));
        // apply any values we got from before the view initialized
        this.value = this.value;
        // TODO: ontouchstart/ontouchmove/ontouchend
        // set up the optional input
        this.inputs = this.getInputs();
        if (this.inputs && this.inputs.length > 0) {
            this.inputs.forEach(function (input, index) {
                input.type = "number";
                input.classList.add("bx--slider-text-input");
                input.classList.add("bx--text-input");
                input.setAttribute("aria-labelledby", _this.bottomRangeId + " " + _this.topRangeId);
                input.value = index < _this._value.length ? _this._value[index].toString() : _this.max.toString();
                // bind events on our optional input
                _this.eventService.on(input, "change", function (event) { return _this.onChange(event, index); });
                if (index === 0) {
                    _this.eventService.on(input, "focus", _this.onFocus.bind(_this));
                }
            });
        }
    };
    Slider.prototype.trackThumbsBy = function (index, item) {
        return index;
    };
    /** Register a change propagation function for `ControlValueAccessor` */
    Slider.prototype.registerOnChange = function (fn) {
        this.propagateChange = fn;
    };
    /** Register a callback to notify when our input has been touched */
    Slider.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    /** Receives a value from the model */
    Slider.prototype.writeValue = function (v) {
        this.value = v;
    };
    /**
     * Returns the amount of "completeness" of a value as a fraction of the total track width
     */
    Slider.prototype.getFractionComplete = function (value) {
        if (!this.track) {
            return 0;
        }
        var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        return this.convertToPx(value) / trackWidth;
    };
    /** Helper function to return the CSS transform `scaleX` function */
    Slider.prototype.scaleX = function (complete) {
        return "scaleX(" + complete + ")";
    };
    /** Converts a given px value to a "real" value in our range */
    Slider.prototype.convertToValue = function (pxAmount) {
        // basic concept borrowed from carbon-components
        // ref: https://github.com/IBM/carbon-components/blob/43bf3abdc2f8bdaa38aa84e0f733adde1e1e8894/src/components/slider/slider.js#L147-L151
        var range = this.max - this.min;
        var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        var unrounded = pxAmount / trackWidth;
        var rounded = Math.round((range * unrounded) / this.step) * this.step;
        return rounded + this.min;
    };
    /** Converts a given "real" value to a px value we can update the view with */
    Slider.prototype.convertToPx = function (value) {
        if (!this.track) {
            return 0;
        }
        var trackWidth = this.track.nativeElement.getBoundingClientRect().width;
        if (value >= this.max) {
            return trackWidth;
        }
        if (value <= this.min) {
            return 0;
        }
        // account for value shifting by subtracting min from value and max
        return Math.round(trackWidth * ((value - this.min) / (this.max - this.min)));
    };
    /**
     * Increments the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    Slider.prototype.incrementValue = function (multiplier, index) {
        if (multiplier === void 0) { multiplier = 1; }
        if (index === void 0) { index = 0; }
        this._value[index] = this._value[index] + (this.step * multiplier);
        this.value = this.value; // run the setter
    };
    /**
     * Decrements the value by the step value, or the step value multiplied by the `multiplier` argument.
     *
     * @argument multiplier Defaults to `1`, multiplied with the step value.
     */
    Slider.prototype.decrementValue = function (multiplier, index) {
        if (multiplier === void 0) { multiplier = 1; }
        if (index === void 0) { index = 0; }
        this._value[index] = this._value[index] - (this.step * multiplier);
        this.value = this.value; // run the setter
    };
    /**
     * Determines if the slider is in range mode.
     */
    Slider.prototype.isRange = function () {
        return this._value.length > 1;
    };
    /**
     * Range mode only.
     * Updates the track width to span from the low thumb to the high thumb
     */
    Slider.prototype.updateTrackRangeWidth = function () {
        var fraction = this.getFractionComplete(this._value[0]);
        var fraction2 = this.getFractionComplete(this._value[1]);
        this.filledTrack.nativeElement.style.transform = "translate(" + fraction * 100 + "%, -50%) " + this.scaleX(fraction2 - fraction);
    };
    /** Change handler for the optional input */
    Slider.prototype.onChange = function (event, index) {
        this._value[index] = Number(event.target.value);
        this.value = this.value;
    };
    /** Handles clicks on the range track, and setting the value to it's "real" equivalent */
    Slider.prototype.onClick = function (event) {
        if (this.disabled) {
            return;
        }
        var trackLeft = this.track.nativeElement.getBoundingClientRect().left;
        this._value[0] = this.convertToValue(event.clientX - trackLeft);
        this.value = this.value;
    };
    /** Focus handler for the optional input */
    Slider.prototype.onFocus = function (_a) {
        var target = _a.target;
        target.select();
    };
    /** Mouse move handler. Responsible for updating the value and visual selection based on mouse movement */
    Slider.prototype.onMouseMove = function (event) {
        if (this.disabled || !this.isMouseDown) {
            return;
        }
        var track = this.track.nativeElement.getBoundingClientRect();
        var value;
        if (event.clientX - track.left <= track.width
            && event.clientX - track.left >= 0) {
            value = this.convertToValue(event.clientX - track.left);
        }
        // if the mouse is beyond the max, set the value to `max`
        if (event.clientX - track.left > track.width) {
            value = this.max;
        }
        // if the mouse is below the min, set the value to `min`
        if (event.clientX - track.left < 0) {
            value = this.min;
        }
        if (value !== undefined) {
            this._value[this._focusedThumbIndex] = value;
            this.value = this.value;
        }
    };
    /**
     * Enables the `onMouseMove` handler
     *
     * @param {boolean} thumb If true then `thumb` is clicked down, otherwise `thumb2` is clicked down.
     */
    Slider.prototype.onMouseDown = function (event, index) {
        if (index === void 0) { index = 0; }
        event.preventDefault();
        if (this.disabled) {
            return;
        }
        this._focusedThumbIndex = index;
        this.thumbs.toArray()[index].nativeElement.focus();
        this.isMouseDown = true;
    };
    /** Disables the `onMouseMove` handler */
    Slider.prototype.onMouseUp = function () {
        this.isMouseDown = false;
    };
    /**
     * Calls `incrementValue` for ArrowRight and ArrowUp, `decrementValue` for ArrowLeft and ArrowDown.
     *
     * @param {boolean} thumb If true then `thumb` is pressed down, otherwise `thumb2` is pressed down.
     */
    Slider.prototype.onKeyDown = function (event, index) {
        if (index === void 0) { index = 0; }
        if (this.disableArrowKeys) {
            return;
        }
        var multiplier = event.shiftKey ? this.shiftMultiplier : 1;
        if (event.key === "ArrowLeft" || event.key === "ArrowDown") {
            this.decrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
        else if (event.key === "ArrowRight" || event.key === "ArrowUp") {
            this.incrementValue(multiplier, index);
            this.thumbs.toArray()[index].nativeElement.focus();
            event.preventDefault();
        }
    };
    Slider.prototype.isTemplate = function (value) {
        return value instanceof TemplateRef;
    };
    /** Get optional input fields */
    Slider.prototype.getInputs = function () {
        return this.elementRef.nativeElement.querySelectorAll("input:not([type=range])");
    };
    /** Used to generate unique IDs */
    Slider.count = 0;
    Slider.decorators = [
        { type: Component, args: [{
                    selector: "ibm-slider",
                    template: "\n\t\t<ng-container *ngIf=\"!skeleton; else skeletonTemplate\">\n\t\t\t<label *ngIf=\"label\" [for]=\"id\" [id]=\"labelId\" class=\"bx--label\">\n\t\t\t\t<ng-container *ngIf=\"!isTemplate(label)\">{{label}}</ng-container>\n\t\t\t\t<ng-template *ngIf=\"isTemplate(label)\" [ngTemplateOutlet]=\"label\"></ng-template>\n\t\t\t</label>\n\t\t\t<div class=\"bx--slider-container\">\n\t\t\t\t<label [id]=\"bottomRangeId\" class=\"bx--slider__range-label\">\n\t\t\t\t\t<ng-content select=\"[minLabel]\"></ng-content>\n\t\t\t\t</label>\n\t\t\t\t<div\n\t\t\t\t\tclass=\"bx--slider\"\n\t\t\t\t\t[ngClass]=\"{'bx--slider--disabled': disabled}\">\n\t\t\t\t\t<ng-container *ngIf=\"!isRange()\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t#thumbs\n\t\t\t\t\t\t\trole=\"slider\"\n\t\t\t\t\t\t\t[id]=\"id\"\n\t\t\t\t\t\t\t[attr.aria-labelledby]=\"labelId\"\n\t\t\t\t\t\t\tclass=\"bx--slider__thumb\"\n\t\t\t\t\t\t\t[ngStyle]=\"{left: getFractionComplete(value) * 100 + '%'}\"\n\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t(mousedown)=\"onMouseDown($event)\"\n\t\t\t\t\t\t\t(keydown)=\"onKeyDown($event)\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-container>\n\t\t\t\t\t<ng-container *ngIf=\"isRange()\">\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t#thumbs\n\t\t\t\t\t\t\t*ngFor=\"let thumb of value; let i = index; trackBy: trackThumbsBy\"\n\t\t\t\t\t\t\trole=\"slider\"\n\t\t\t\t\t\t\t[id]=\"id + (i > 0 ? '-' + i : '')\"\n\t\t\t\t\t\t\t[attr.aria-labelledby]=\"labelId\"\n\t\t\t\t\t\t\tclass=\"bx--slider__thumb\"\n\t\t\t\t\t\t\t[ngStyle]=\"{left: getFractionComplete(thumb) * 100 + '%'}\"\n\t\t\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\t\t\t(mousedown)=\"onMouseDown($event, i)\"\n\t\t\t\t\t\t\t(keydown)=\"onKeyDown($event, i)\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</ng-container>\n\t\t\t\t\t<div\n\t\t\t\t\t\t#track\n\t\t\t\t\t\tclass=\"bx--slider__track\"\n\t\t\t\t\t\t(click)=\"onClick($event)\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<div\n\t\t\t\t\t\t#filledTrack\n\t\t\t\t\t\tclass=\"bx--slider__filled-track\">\n\t\t\t\t\t</div>\n\t\t\t\t\t<input\n\t\t\t\t\t\t#range\n\t\t\t\t\t\taria-label=\"slider\"\n\t\t\t\t\t\tclass=\"bx--slider__input\"\n\t\t\t\t\t\ttype=\"range\"\n\t\t\t\t\t\t[step]=\"step\"\n\t\t\t\t\t\t[min]=\"min\"\n\t\t\t\t\t\t[max]=\"max\"\n\t\t\t\t\t\t[value]=\"value.toString()\">\n\t\t\t\t</div>\n\t\t\t\t<label [id]=\"topRangeId\" class=\"bx--slider__range-label\">\n\t\t\t\t\t<ng-content select=\"[maxLabel]\"></ng-content>\n\t\t\t\t</label>\n\t\t\t\t<ng-content select=\"input\"></ng-content>\n\t\t\t</div>\n\t\t</ng-container>\n\n\t\t<ng-template #skeletonTemplate>\n\t\t\t<label *ngIf=\"label\" class=\"bx--label bx--skeleton\"></label>\n\t\t\t<div class=\"bx--slider-container bx--skeleton\">\n\t\t\t\t<span class=\"bx--slider__range-label\"></span>\n\t\t\t\t<div class=\"bx--slider\">\n\t\t\t\t\t<div class=\"bx--slider__thumb\"></div>\n\t\t\t\t\t<div class=\"bx--slider__track\"></div>\n\t\t\t\t\t<div class=\"bx--slider__filled-track\"></div>\n\t\t\t\t</div>\n\t\t\t\t<span class=\"bx--slider__range-label\"></span>\n\t\t\t</div>\n\t\t</ng-template>\n\t",
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: Slider,
                            multi: true
                        }
                    ]
                }] }
    ];
    /** @nocollapse */
    Slider.ctorParameters = function () { return [
        { type: ElementRef },
        { type: EventService }
    ]; };
    Slider.propDecorators = {
        min: [{ type: Input }],
        max: [{ type: Input }],
        step: [{ type: Input }],
        value: [{ type: Input }],
        id: [{ type: Input }],
        shiftMultiplier: [{ type: Input }],
        skeleton: [{ type: Input }],
        label: [{ type: Input }],
        disableArrowKeys: [{ type: Input }],
        disabled: [{ type: Input }],
        valueChange: [{ type: Output }],
        hostClass: [{ type: HostBinding, args: ["class.bx--form-item",] }],
        thumbs: [{ type: ViewChildren, args: ["thumbs",] }],
        track: [{ type: ViewChild, args: ["track", { static: false },] }],
        filledTrack: [{ type: ViewChild, args: ["filledTrack", { static: false },] }],
        range: [{ type: ViewChild, args: ["range", { static: false },] }]
    };
    return Slider;
}());
export { Slider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvc2xpZGVyLyIsInNvdXJjZXMiOlsic2xpZGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxXQUFXLEVBQ1gsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBRVosU0FBUyxFQUNULFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLFNBQVMsRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBRS9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNIO0lBeU9DLGdCQUFzQixVQUFzQixFQUFZLFlBQTBCO1FBQTVELGVBQVUsR0FBVixVQUFVLENBQVk7UUFBWSxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQXZIbEYsaUNBQWlDO1FBQ3hCLFNBQUksR0FBRyxDQUFDLENBQUM7UUFzRWxCLCtIQUErSDtRQUN0SCxPQUFFLEdBQUcsWUFBVSxNQUFNLENBQUMsS0FBSyxFQUFJLENBQUM7UUFDekMsaUZBQWlGO1FBQ3hFLG9CQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQzdCLHlDQUF5QztRQUNoQyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRzFCLGlFQUFpRTtRQUN4RCxxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFjbEMsK0NBQStDO1FBQ3JDLGdCQUFXLEdBQW9DLElBQUksWUFBWSxFQUFFLENBQUM7UUFDeEMsY0FBUyxHQUFHLElBQUksQ0FBQztRQVM5QyxZQUFPLEdBQU0sSUFBSSxDQUFDLEVBQUUsV0FBUSxDQUFDO1FBQzdCLGtCQUFhLEdBQU0sSUFBSSxDQUFDLEVBQUUsa0JBQWUsQ0FBQztRQUMxQyxlQUFVLEdB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dENvbXBvbmVudCxcblx0SG9zdEJpbmRpbmcsXG5cdElucHV0LFxuXHRPdXRwdXQsXG5cdEV2ZW50RW1pdHRlcixcblx0QWZ0ZXJWaWV3SW5pdCxcblx0Vmlld0NoaWxkLFxuXHRFbGVtZW50UmVmLFxuXHRUZW1wbGF0ZVJlZixcblx0Vmlld0NoaWxkcmVuLFxuXHRRdWVyeUxpc3Rcbn0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgRXZlbnRTZXJ2aWNlIH0gZnJvbSBcImNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHNcIjtcblxuLyoqXG4gKiBVc2VkIHRvIHNlbGVjdCBmcm9tIHJhbmdlcyBvZiB2YWx1ZXMuIFtTZWUgaGVyZV0oaHR0cHM6Ly93d3cuY2FyYm9uZGVzaWduc3lzdGVtLmNvbS9jb21wb25lbnRzL3NsaWRlci91c2FnZSkgZm9yIHVzYWdlIGluZm9ybWF0aW9uLlxuICpcbiAqIFtTZWUgZGVtb10oLi4vLi4vP3BhdGg9L3N0b3J5L3NsaWRlci0tYWR2YW5jZWQpXG4gKlxuICogVGhlIHNpbXBsZXN0IHBvc3NpYmxlIHNsaWRlciB1c2FnZSBsb29rcyBzb21ldGhpbmcgbGlrZTpcbiAqIGBgYGh0bWxcbiAqIDxpYm0tc2xpZGVyPjwvaWJtLXNsaWRlcj5cbiAqIGBgYFxuICpcbiAqIFRoYXQgd2lsbCByZW5kZXIgYSBzbGlkZXIgd2l0aG91dCBsYWJlbHMgb3IgYWx0ZXJuYXRpdmUgdmFsdWUgaW5wdXQuIExhYmVscyBjYW4gYmUgcHJvdmlkZWQgYnlcbiAqIGVsZW1lbnRzIHdpdGggYFttaW5MYWJlbF1gIGFuZCBgW21heExhYmVsXWAgYXR0cmlidXRlcywgYW5kIGFuIGBpbnB1dGAgKG1heSB1c2UgdGhlIGBpYm1JbnB1dGAgZGlyZWN0aXZlKSBjYW4gYmUgc3VwcGxpZWRcbiAqIGZvciB1c2UgYXMgYW4gYWx0ZXJuYXRpdmUgdmFsdWUgZmllbGQuXG4gKlxuICogZXg6XG4gKiBgYGBodG1sXG4gKiA8IS0tIGZ1bGwgZXhhbXBsZSAtLT5cbiAqIDxpYm0tc2xpZGVyPlxuICpcdFx0PHNwYW4gbWluTGFiZWw+MEdCPC9zcGFuPlxuICpcdFx0PHNwYW4gbWF4TGFiZWw+MTAwR0I8L3NwYW4+XG4gKlx0XHQ8aW5wdXQvPlxuICpcdDwvaWJtLXNsaWRlcj5cbiAqIDwhLS0gd2l0aCBqdXN0IGFuIGlucHV0IC0tPlxuICogPGlibS1zbGlkZXI+XG4gKlx0XHQ8aW5wdXQvPlxuICpcdDwvaWJtLXNsaWRlcj5cbiAqIDwhLS0gd2l0aCBqdXN0IG9uZSBsYWJlbCAtLT5cbiAqIDxpYm0tc2xpZGVyPlxuICpcdFx0PHNwYW4gbWF4TGFiZWw+TWF4aW11bTwvc3Bhbj5cbiAqXHQ8L2libS1zbGlkZXI+XG4gKiBgYGBcbiAqXG4gKiBTbGlkZXIgc3VwcG9ydHMgYE5nTW9kZWxgIGJ5IGRlZmF1bHQsIGFzIHdlbGwgYXMgdHdvIHdheSBiaW5kaW5nIHRvIHRoZSBgdmFsdWVgIGlucHV0LlxuICpcbiAqIDxleGFtcGxlLXVybD4uLi8uLi9pZnJhbWUuaHRtbD9pZD1zbGlkZXItLWFkdmFuY2VkPC9leGFtcGxlLXVybD5cbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiBcImlibS1zbGlkZXJcIixcblx0dGVtcGxhdGU6IGBcblx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIXNrZWxldG9uOyBlbHNlIHNrZWxldG9uVGVtcGxhdGVcIj5cblx0XHRcdDxsYWJlbCAqbmdJZj1cImxhYmVsXCIgW2Zvcl09XCJpZFwiIFtpZF09XCJsYWJlbElkXCIgY2xhc3M9XCJieC0tbGFiZWxcIj5cblx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGxhYmVsKVwiPnt7bGFiZWx9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGxhYmVsKVwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxhYmVsXCI+PC9uZy10ZW1wbGF0ZT5cblx0XHRcdDwvbGFiZWw+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNsaWRlci1jb250YWluZXJcIj5cblx0XHRcdFx0PGxhYmVsIFtpZF09XCJib3R0b21SYW5nZUlkXCIgY2xhc3M9XCJieC0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cIlttaW5MYWJlbF1cIj48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRjbGFzcz1cImJ4LS1zbGlkZXJcIlxuXHRcdFx0XHRcdFtuZ0NsYXNzXT1cInsnYngtLXNsaWRlci0tZGlzYWJsZWQnOiBkaXNhYmxlZH1cIj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzUmFuZ2UoKVwiPlxuXHRcdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0XHQjdGh1bWJzXG5cdFx0XHRcdFx0XHRcdHJvbGU9XCJzbGlkZXJcIlxuXHRcdFx0XHRcdFx0XHRbaWRdPVwiaWRcIlxuXHRcdFx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwibGFiZWxJZFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLXNsaWRlcl9fdGh1bWJcIlxuXHRcdFx0XHRcdFx0XHRbbmdTdHlsZV09XCJ7bGVmdDogZ2V0RnJhY3Rpb25Db21wbGV0ZSh2YWx1ZSkgKiAxMDAgKyAnJSd9XCJcblx0XHRcdFx0XHRcdFx0dGFiaW5kZXg9XCIwXCJcblx0XHRcdFx0XHRcdFx0KG1vdXNlZG93bik9XCJvbk1vdXNlRG93bigkZXZlbnQpXCJcblx0XHRcdFx0XHRcdFx0KGtleWRvd24pPVwib25LZXlEb3duKCRldmVudClcIj5cblx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDwvbmctY29udGFpbmVyPlxuXHRcdFx0XHRcdDxuZy1jb250YWluZXIgKm5nSWY9XCJpc1JhbmdlKClcIj5cblx0XHRcdFx0XHRcdDxkaXZcblx0XHRcdFx0XHRcdFx0I3RodW1ic1xuXHRcdFx0XHRcdFx0XHQqbmdGb3I9XCJsZXQgdGh1bWIgb2YgdmFsdWU7IGxldCBpID0gaW5kZXg7IHRyYWNrQnk6IHRyYWNrVGh1bWJzQnlcIlxuXHRcdFx0XHRcdFx0XHRyb2xlPVwic2xpZGVyXCJcblx0XHRcdFx0XHRcdFx0W2lkXT1cImlkICsgKGkgPiAwID8gJy0nICsgaSA6ICcnKVwiXG5cdFx0XHRcdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJsYWJlbElkXCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tc2xpZGVyX190aHVtYlwiXG5cdFx0XHRcdFx0XHRcdFtuZ1N0eWxlXT1cIntsZWZ0OiBnZXRGcmFjdGlvbkNvbXBsZXRlKHRodW1iKSAqIDEwMCArICclJ31cIlxuXHRcdFx0XHRcdFx0XHR0YWJpbmRleD1cIjBcIlxuXHRcdFx0XHRcdFx0XHQobW91c2Vkb3duKT1cIm9uTW91c2VEb3duKCRldmVudCwgaSlcIlxuXHRcdFx0XHRcdFx0XHQoa2V5ZG93bik9XCJvbktleURvd24oJGV2ZW50LCBpKVwiPlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0I3RyYWNrXG5cdFx0XHRcdFx0XHRjbGFzcz1cImJ4LS1zbGlkZXJfX3RyYWNrXCJcblx0XHRcdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHQjZmlsbGVkVHJhY2tcblx0XHRcdFx0XHRcdGNsYXNzPVwiYngtLXNsaWRlcl9fZmlsbGVkLXRyYWNrXCI+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGlucHV0XG5cdFx0XHRcdFx0XHQjcmFuZ2Vcblx0XHRcdFx0XHRcdGFyaWEtbGFiZWw9XCJzbGlkZXJcIlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJieC0tc2xpZGVyX19pbnB1dFwiXG5cdFx0XHRcdFx0XHR0eXBlPVwicmFuZ2VcIlxuXHRcdFx0XHRcdFx0W3N0ZXBdPVwic3RlcFwiXG5cdFx0XHRcdFx0XHRbbWluXT1cIm1pblwiXG5cdFx0XHRcdFx0XHRbbWF4XT1cIm1heFwiXG5cdFx0XHRcdFx0XHRbdmFsdWVdPVwidmFsdWUudG9TdHJpbmcoKVwiPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PGxhYmVsIFtpZF09XCJ0b3BSYW5nZUlkXCIgY2xhc3M9XCJieC0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPlxuXHRcdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cIlttYXhMYWJlbF1cIj48L25nLWNvbnRlbnQ+XG5cdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdDxuZy1jb250ZW50IHNlbGVjdD1cImlucHV0XCI+PC9uZy1jb250ZW50PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9uZy1jb250YWluZXI+XG5cblx0XHQ8bmctdGVtcGxhdGUgI3NrZWxldG9uVGVtcGxhdGU+XG5cdFx0XHQ8bGFiZWwgKm5nSWY9XCJsYWJlbFwiIGNsYXNzPVwiYngtLWxhYmVsIGJ4LS1za2VsZXRvblwiPjwvbGFiZWw+XG5cdFx0XHQ8ZGl2IGNsYXNzPVwiYngtLXNsaWRlci1jb250YWluZXIgYngtLXNrZWxldG9uXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPVwiYngtLXNsaWRlcl9fcmFuZ2UtbGFiZWxcIj48L3NwYW4+XG5cdFx0XHRcdDxkaXYgY2xhc3M9XCJieC0tc2xpZGVyXCI+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1zbGlkZXJfX3RodW1iXCI+PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1zbGlkZXJfX3RyYWNrXCI+PC9kaXY+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz1cImJ4LS1zbGlkZXJfX2ZpbGxlZC10cmFja1wiPjwvZGl2PlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PHNwYW4gY2xhc3M9XCJieC0tc2xpZGVyX19yYW5nZS1sYWJlbFwiPjwvc3Bhbj5cblx0XHRcdDwvZGl2PlxuXHRcdDwvbmctdGVtcGxhdGU+XG5cdGAsXG5cdHByb3ZpZGVyczogW1xuXHRcdHtcblx0XHRcdHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuXHRcdFx0dXNlRXhpc3Rpbmc6IFNsaWRlcixcblx0XHRcdG11bHRpOiB0cnVlXG5cdFx0fVxuXHRdXG59KVxuZXhwb3J0IGNsYXNzIFNsaWRlciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblx0LyoqIFVzZWQgdG8gZ2VuZXJhdGUgdW5pcXVlIElEcyAqL1xuXHRwcml2YXRlIHN0YXRpYyBjb3VudCA9IDA7XG5cblx0LyoqIFRoZSBsb3dlciBib3VuZCBvZiBvdXIgcmFuZ2UgKi9cblx0QElucHV0KCkgc2V0IG1pbih2KSB7XG5cdFx0aWYgKCF2KSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX21pbiA9IHY7XG5cdFx0Ly8gZm9yY2UgdGhlIGNvbXBvbmVudCB0byB1cGRhdGVcblx0XHR0aGlzLnZhbHVlID0gdGhpcy52YWx1ZTtcblx0fVxuXHRnZXQgbWluKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW47XG5cdH1cblx0LyoqIFRoZSB1cHBlciBib3VuZCBvZiBvdXIgcmFuZ2UgKi9cblx0QElucHV0KCkgc2V0IG1heCh2KSB7XG5cdFx0aWYgKCF2KSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX21heCA9IHY7XG5cdFx0Ly8gZm9yY2UgdGhlIGNvbXBvbmVudCB0byB1cGRhdGVcblx0XHR0aGlzLnZhbHVlID0gdGhpcy52YWx1ZTtcblx0fVxuXG5cdGdldCBtYXgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heDtcblx0fVxuXHQvKiogVGhlIGludGVydmFsIGZvciBvdXIgcmFuZ2UgKi9cblx0QElucHV0KCkgc3RlcCA9IDE7XG5cdC8qKiBTZXQgdGhlIGluaXRpYWwgdmFsdWUuIEF2YWlsYWJsZSBmb3IgdHdvIHdheSBiaW5kaW5nICovXG5cdEBJbnB1dCgpIHNldCB2YWx1ZSh2KSB7XG5cdFx0aWYgKCF2KSB7XG5cdFx0XHR2ID0gW3RoaXMubWluXTtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHYgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHYgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHYgPSBbTnVtYmVyKHYpXTtcblx0XHR9XG5cblx0XHRpZiAodlswXSA8IHRoaXMubWluKSB7XG5cdFx0XHR2WzBdID0gdGhpcy5taW47XG5cdFx0fVxuXG5cdFx0aWYgKHZbMF0gPiB0aGlzLm1heCkge1xuXHRcdFx0dlswXSA9IHRoaXMubWF4O1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUmFuZ2UoKSkge1xuXHRcdFx0aWYgKHRoaXMuX3ByZXZpb3VzVmFsdWVbMF0gIT09IHZbMF0pIHsgLy8gbGVmdCBtb3ZlZFxuXHRcdFx0XHRpZiAodlswXSA+IHZbMV0gLSB0aGlzLnN0ZXApIHtcblx0XHRcdFx0XHQvLyBzdG9wIHRoZSBsZWZ0IGhhbmRsZSBpZiBzdXJwYXNzaW5nIHRoZSByaWdodCBvbmVcblx0XHRcdFx0XHR2WzBdID0gdlsxXSAtIHRoaXMuc3RlcDtcblx0XHRcdFx0fSBlbHNlIGlmICh2WzBdID4gdGhpcy5tYXgpIHtcblx0XHRcdFx0XHR2WzBdID0gdGhpcy5tYXg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodlswXSA8IHRoaXMubWluKSB7XG5cdFx0XHRcdFx0dlswXSA9IHRoaXMubWluO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLl9wcmV2aW91c1ZhbHVlWzFdICE9PSB2WzFdKSB7IC8vIHJpZ2h0IG1vdmVkXG5cdFx0XHRcdGlmICh2WzFdID4gdGhpcy5tYXgpIHtcblx0XHRcdFx0XHR2WzFdID0gdGhpcy5tYXg7XG5cdFx0XHRcdH0gZWxzZSBpZiAodlsxXSA8IHRoaXMuX3ZhbHVlWzBdICsgdGhpcy5zdGVwKSB7XG5cdFx0XHRcdFx0Ly8gc3RvcCB0aGUgcmlnaHQgaGFuZGxlIGlmIHN1cnBhc3NpbmcgdGhlIGxlZnQgb25lXG5cdFx0XHRcdFx0dlsxXSA9IHRoaXMuX3ZhbHVlWzBdICsgdGhpcy5zdGVwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZbMV0gPCB0aGlzLm1pbikge1xuXHRcdFx0XHRcdHZbMV0gPSB0aGlzLm1pbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX3ByZXZpb3VzVmFsdWUgPSBbLi4udGhpcy5fdmFsdWVdOyAvLyBzdG9yZSBhIGNvcHksIGVuYWJsZSBkZXRlY3Rpb24gd2hpY2ggaGFuZGxlIG1vdmVkXG5cdFx0dGhpcy5fdmFsdWUgPSBbLi4udl07IC8vIHRyaWdnZXJzIGNoYW5nZSBkZXRlY3Rpb24gd2hlbiBuZ01vZGVsIHZhbHVlIGlzIGFuIGFycmF5IChmb3IgcmFuZ2UpXG5cblx0XHRpZiAodGhpcy5pc1JhbmdlKCkgJiYgdGhpcy5maWxsZWRUcmFjaykge1xuXHRcdFx0dGhpcy51cGRhdGVUcmFja1JhbmdlV2lkdGgoKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuZmlsbGVkVHJhY2spIHtcblx0XHRcdHRoaXMuZmlsbGVkVHJhY2submF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKDAlLCAtNTAlKSAke3RoaXMuc2NhbGVYKHRoaXMuZ2V0RnJhY3Rpb25Db21wbGV0ZSh2WzBdKSl9YDtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pbnB1dHMgJiYgdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG5cdFx0XHR0aGlzLmlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcblx0XHRcdFx0aW5wdXQudmFsdWUgPSB0aGlzLl92YWx1ZVtpbmRleF0udG9TdHJpbmcoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGNvbnN0IHZhbHVlVG9FbWl0ID0gdGhpcy5pc1JhbmdlKCkgPyB2IDogdlswXTtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSh2YWx1ZVRvRW1pdCk7XG5cdFx0dGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlVG9FbWl0KTtcblx0fVxuXG5cdGdldCB2YWx1ZSgpIHtcblx0XHRpZiAodGhpcy5pc1JhbmdlKCkpIHtcblx0XHRcdHJldHVybiB0aGlzLl92YWx1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlWzBdO1xuXHR9XG5cblx0LyoqIEJhc2UgSUQgZm9yIHRoZSBzbGlkZXIuIFRoZSBtaW4gYW5kIG1heCBsYWJlbHMgZ2V0IElEcyBgJHt0aGlzLmlkfS1ib3R0b20tcmFuZ2VgIGFuZCBgJHt0aGlzLmlkfS10b3AtcmFuZ2VgIHJlc3BlY3RpdmVseSAqL1xuXHRASW5wdXQoKSBpZCA9IGBzbGlkZXItJHtTbGlkZXIuY291bnQrK31gO1xuXHQvKiogVmFsdWUgdXNlZCB0byBcIm11bHRpcGx5XCIgdGhlIGBzdGVwYCB3aGVuIHVzaW5nIGFycm93IGtleXMgdG8gc2VsZWN0IHZhbHVlcyAqL1xuXHRASW5wdXQoKSBzaGlmdE11bHRpcGxpZXIgPSA0O1xuXHQvKiogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIHNsaWRlciAqL1xuXHRASW5wdXQoKSBza2VsZXRvbiA9IGZhbHNlO1xuXHQvKiogU2V0cyB0aGUgdGV4dCBpbnNpZGUgdGhlIGBsYWJlbGAgdGFnICovXG5cdEBJbnB1dCgpIGxhYmVsOiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+O1xuXHQvKiogU2V0IHRvIGB0cnVlYCBmb3IgYSBzbGlkZXIgd2l0aG91dCBhcnJvdyBrZXkgaW50ZXJhY3Rpb25zLiAqL1xuXHRASW5wdXQoKSBkaXNhYmxlQXJyb3dLZXlzID0gZmFsc2U7XG5cdC8qKiBEaXNhYmxlcyB0aGUgcmFuZ2UgdmlzdWFsbHkgYW5kIGZ1bmN0aW9uYWxseSAqL1xuXHRASW5wdXQoKSBzZXQgZGlzYWJsZWQodikge1xuXHRcdHRoaXMuX2Rpc2FibGVkID0gdjtcblx0XHQvLyBmb3Igc29tZSByZWFzb24gYHRoaXMuaW5wdXRgIG5ldmVyIGV4aXN0cyBoZXJlLCBzbyB3ZSBoYXZlIHRvIHF1ZXJ5IGZvciBpdCBoZXJlIHRvb1xuXHRcdGNvbnN0IGlucHV0cyA9IHRoaXMuZ2V0SW5wdXRzKCk7XG5cdFx0aWYgKGlucHV0cyAmJiBpbnB1dHMubGVuZ3RoID4gMCkge1xuXHRcdFx0aW5wdXRzLmZvckVhY2goaW5wdXQgPT4gaW5wdXQuZGlzYWJsZWQgPSB2KTtcblx0XHR9XG5cdH1cblxuXHRnZXQgZGlzYWJsZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuXHR9XG5cdC8qKiBFbWl0cyBldmVyeSB0aW1lIGEgbmV3IHZhbHVlIGlzIHNlbGVjdGVkICovXG5cdEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPG51bWJlciB8IG51bWJlcltdPiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0QEhvc3RCaW5kaW5nKFwiY2xhc3MuYngtLWZvcm0taXRlbVwiKSBob3N0Q2xhc3MgPSB0cnVlO1xuXHRAVmlld0NoaWxkcmVuKFwidGh1bWJzXCIpIHRodW1iczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuXHQvLyBAdHMtaWdub3JlXG5cdEBWaWV3Q2hpbGQoXCJ0cmFja1wiLCB7IHN0YXRpYzogZmFsc2UgfSkgdHJhY2s6IEVsZW1lbnRSZWY7XG5cdC8vIEB0cy1pZ25vcmVcblx0QFZpZXdDaGlsZChcImZpbGxlZFRyYWNrXCIsIHsgc3RhdGljOiBmYWxzZSB9KSBmaWxsZWRUcmFjazogRWxlbWVudFJlZjtcblx0Ly8gQHRzLWlnbm9yZVxuXHRAVmlld0NoaWxkKFwicmFuZ2VcIiwgeyBzdGF0aWM6IGZhbHNlIH0pIHJhbmdlOiBFbGVtZW50UmVmO1xuXG5cdHB1YmxpYyBsYWJlbElkID0gYCR7dGhpcy5pZH0tbGFiZWxgO1xuXHRwdWJsaWMgYm90dG9tUmFuZ2VJZCA9IGAke3RoaXMuaWR9LWJvdHRvbS1yYW5nZWA7XG5cdHB1YmxpYyB0b3BSYW5nZUlkID0gYCR7dGhpcy5pZH0tdG9wLXJhbmdlYDtcblx0cHVibGljIGZyYWN0aW9uQ29tcGxldGUgPSAwO1xuXG5cdHByb3RlY3RlZCBpc01vdXNlRG93biA9IGZhbHNlO1xuXHRwcm90ZWN0ZWQgaW5wdXRzOiBIVE1MSW5wdXRFbGVtZW50W107XG5cdHByb3RlY3RlZCBfbWluID0gMDtcblx0cHJvdGVjdGVkIF9tYXggPSAxMDA7XG5cdHByb3RlY3RlZCBfdmFsdWUgPSBbdGhpcy5taW5dO1xuXHRwcm90ZWN0ZWQgX3ByZXZpb3VzVmFsdWUgPSBbdGhpcy5taW5dO1xuXHRwcm90ZWN0ZWQgX2Rpc2FibGVkID0gZmFsc2U7XG5cdHByb3RlY3RlZCBfZm9jdXNlZFRodW1iSW5kZXggPSAwO1xuXG5cdGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcm90ZWN0ZWQgZXZlbnRTZXJ2aWNlOiBFdmVudFNlcnZpY2UpIHt9XG5cblx0bmdBZnRlclZpZXdJbml0KCkge1xuXHRcdC8vIGJpbmQgbW91c2Vtb3ZlIGFuZCBtb3VzZXVwIHRvIHRoZSBkb2N1bWVudCBzbyB3ZSBkb24ndCBoYXZlIGlzc3VlcyB0cmFja2luZyB0aGUgbW91c2Vcblx0XHR0aGlzLmV2ZW50U2VydmljZS5vbkRvY3VtZW50KFwibW91c2Vtb3ZlXCIsIHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5ldmVudFNlcnZpY2Uub25Eb2N1bWVudChcIm1vdXNldXBcIiwgdGhpcy5vbk1vdXNlVXAuYmluZCh0aGlzKSk7XG5cblx0XHQvLyBhcHBseSBhbnkgdmFsdWVzIHdlIGdvdCBmcm9tIGJlZm9yZSB0aGUgdmlldyBpbml0aWFsaXplZFxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXG5cdFx0Ly8gVE9ETzogb250b3VjaHN0YXJ0L29udG91Y2htb3ZlL29udG91Y2hlbmRcblxuXHRcdC8vIHNldCB1cCB0aGUgb3B0aW9uYWwgaW5wdXRcblx0XHR0aGlzLmlucHV0cyA9IHRoaXMuZ2V0SW5wdXRzKCk7XG5cdFx0aWYgKHRoaXMuaW5wdXRzICYmIHRoaXMuaW5wdXRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0LCBpbmRleCkgPT4ge1xuXHRcdFx0XHRpbnB1dC50eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdFx0aW5wdXQuY2xhc3NMaXN0LmFkZChcImJ4LS1zbGlkZXItdGV4dC1pbnB1dFwiKTtcblx0XHRcdFx0aW5wdXQuY2xhc3NMaXN0LmFkZChcImJ4LS10ZXh0LWlucHV0XCIpO1xuXHRcdFx0XHRpbnB1dC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIiwgYCR7dGhpcy5ib3R0b21SYW5nZUlkfSAke3RoaXMudG9wUmFuZ2VJZH1gKTtcblxuXHRcdFx0XHRpbnB1dC52YWx1ZSA9IGluZGV4IDwgdGhpcy5fdmFsdWUubGVuZ3RoID8gdGhpcy5fdmFsdWVbaW5kZXhdLnRvU3RyaW5nKCkgOiB0aGlzLm1heC50b1N0cmluZygpO1xuXHRcdFx0XHQvLyBiaW5kIGV2ZW50cyBvbiBvdXIgb3B0aW9uYWwgaW5wdXRcblx0XHRcdFx0dGhpcy5ldmVudFNlcnZpY2Uub24oaW5wdXQsIFwiY2hhbmdlXCIsIGV2ZW50ID0+IHRoaXMub25DaGFuZ2UoZXZlbnQsIGluZGV4KSk7XG5cblx0XHRcdFx0aWYgKGluZGV4ID09PSAwKSB7XG5cdFx0XHRcdFx0dGhpcy5ldmVudFNlcnZpY2Uub24oaW5wdXQsIFwiZm9jdXNcIiwgdGhpcy5vbkZvY3VzLmJpbmQodGhpcykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblxuXHR0cmFja1RodW1ic0J5KGluZGV4OiBudW1iZXIsIGl0ZW06IGFueSkge1xuXHRcdHJldHVybiBpbmRleDtcblx0fVxuXG5cdC8qKiBTZW5kIGNoYW5nZXMgYmFjayB0byB0aGUgbW9kZWwgKi9cblx0cHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xuXG5cdC8qKiBSZWdpc3RlciBhIGNoYW5nZSBwcm9wYWdhdGlvbiBmdW5jdGlvbiBmb3IgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCAqL1xuXHRyZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpIHtcblx0XHR0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuO1xuXHR9XG5cblx0LyoqIENhbGxiYWNrIHRvIG5vdGlmeSB0aGUgbW9kZWwgd2hlbiBvdXIgaW5wdXQgaGFzIGJlZW4gdG91Y2hlZCAqL1xuXHRvblRvdWNoZWQ6ICgpID0+IGFueSA9ICgpID0+IHsgfTtcblxuXHQvKiogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBub3RpZnkgd2hlbiBvdXIgaW5wdXQgaGFzIGJlZW4gdG91Y2hlZCAqL1xuXHRyZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XG5cdFx0dGhpcy5vblRvdWNoZWQgPSBmbjtcblx0fVxuXG5cdC8qKiBSZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIG1vZGVsICovXG5cdHdyaXRlVmFsdWUodjogYW55KSB7XG5cdFx0dGhpcy52YWx1ZSA9IHY7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgYW1vdW50IG9mIFwiY29tcGxldGVuZXNzXCIgb2YgYSB2YWx1ZSBhcyBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB0cmFjayB3aWR0aFxuXHQgKi9cblx0Z2V0RnJhY3Rpb25Db21wbGV0ZSh2YWx1ZTogbnVtYmVyKSB7XG5cdFx0aWYgKCF0aGlzLnRyYWNrKSB7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHRjb25zdCB0cmFja1dpZHRoID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRUb1B4KHZhbHVlKSAvIHRyYWNrV2lkdGg7XG5cdH1cblxuXHQvKiogSGVscGVyIGZ1bmN0aW9uIHRvIHJldHVybiB0aGUgQ1NTIHRyYW5zZm9ybSBgc2NhbGVYYCBmdW5jdGlvbiAqL1xuXHRzY2FsZVgoY29tcGxldGUpIHtcblx0XHRyZXR1cm4gYHNjYWxlWCgke2NvbXBsZXRlfSlgO1xuXHR9XG5cblx0LyoqIENvbnZlcnRzIGEgZ2l2ZW4gcHggdmFsdWUgdG8gYSBcInJlYWxcIiB2YWx1ZSBpbiBvdXIgcmFuZ2UgKi9cblx0Y29udmVydFRvVmFsdWUocHhBbW91bnQpIHtcblx0XHQvLyBiYXNpYyBjb25jZXB0IGJvcnJvd2VkIGZyb20gY2FyYm9uLWNvbXBvbmVudHNcblx0XHQvLyByZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9JQk0vY2FyYm9uLWNvbXBvbmVudHMvYmxvYi80M2JmM2FiZGMyZjhiZGFhMzhhYTg0ZTBmNzMzYWRkZTFlMWU4ODk0L3NyYy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuanMjTDE0Ny1MMTUxXG5cdFx0Y29uc3QgcmFuZ2UgPSB0aGlzLm1heCAtIHRoaXMubWluO1xuXHRcdGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cdFx0Y29uc3QgdW5yb3VuZGVkID0gcHhBbW91bnQgLyB0cmFja1dpZHRoO1xuXHRcdGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKChyYW5nZSAqIHVucm91bmRlZCkgLyB0aGlzLnN0ZXApICogdGhpcy5zdGVwO1xuXHRcdHJldHVybiByb3VuZGVkICsgdGhpcy5taW47XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBnaXZlbiBcInJlYWxcIiB2YWx1ZSB0byBhIHB4IHZhbHVlIHdlIGNhbiB1cGRhdGUgdGhlIHZpZXcgd2l0aCAqL1xuXHRjb252ZXJ0VG9QeCh2YWx1ZSkge1xuXHRcdGlmICghdGhpcy50cmFjaykge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Y29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblx0XHRpZiAodmFsdWUgPj0gdGhpcy5tYXgpIHtcblx0XHRcdHJldHVybiB0cmFja1dpZHRoO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSA8PSB0aGlzLm1pbikge1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gYWNjb3VudCBmb3IgdmFsdWUgc2hpZnRpbmcgYnkgc3VidHJhY3RpbmcgbWluIGZyb20gdmFsdWUgYW5kIG1heFxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHRyYWNrV2lkdGggKiAoKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5jcmVtZW50cyB0aGUgdmFsdWUgYnkgdGhlIHN0ZXAgdmFsdWUsIG9yIHRoZSBzdGVwIHZhbHVlIG11bHRpcGxpZWQgYnkgdGhlIGBtdWx0aXBsaWVyYCBhcmd1bWVudC5cblx0ICpcblx0ICogQGFyZ3VtZW50IG11bHRpcGxpZXIgRGVmYXVsdHMgdG8gYDFgLCBtdWx0aXBsaWVkIHdpdGggdGhlIHN0ZXAgdmFsdWUuXG5cdCAqL1xuXHRpbmNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyID0gMSwgaW5kZXggPSAwKSB7XG5cdFx0dGhpcy5fdmFsdWVbaW5kZXhdID0gdGhpcy5fdmFsdWVbaW5kZXhdICsgKHRoaXMuc3RlcCAqIG11bHRpcGxpZXIpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlOyAvLyBydW4gdGhlIHNldHRlclxuXHR9XG5cblx0LyoqXG5cdCAqIERlY3JlbWVudHMgdGhlIHZhbHVlIGJ5IHRoZSBzdGVwIHZhbHVlLCBvciB0aGUgc3RlcCB2YWx1ZSBtdWx0aXBsaWVkIGJ5IHRoZSBgbXVsdGlwbGllcmAgYXJndW1lbnQuXG5cdCAqXG5cdCAqIEBhcmd1bWVudCBtdWx0aXBsaWVyIERlZmF1bHRzIHRvIGAxYCwgbXVsdGlwbGllZCB3aXRoIHRoZSBzdGVwIHZhbHVlLlxuXHQgKi9cblx0ZGVjcmVtZW50VmFsdWUobXVsdGlwbGllciA9IDEsIGluZGV4ID0gMCkge1xuXHRcdHRoaXMuX3ZhbHVlW2luZGV4XSA9IHRoaXMuX3ZhbHVlW2luZGV4XSAtICh0aGlzLnN0ZXAgKiBtdWx0aXBsaWVyKTtcblx0XHR0aGlzLnZhbHVlID0gdGhpcy52YWx1ZTsgLy8gcnVuIHRoZSBzZXR0ZXJcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXRlcm1pbmVzIGlmIHRoZSBzbGlkZXIgaXMgaW4gcmFuZ2UgbW9kZS5cblx0ICovXG5cdGlzUmFuZ2UoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbHVlLmxlbmd0aCA+IDE7XG5cdH1cblxuXHQvKipcblx0ICogUmFuZ2UgbW9kZSBvbmx5LlxuXHQgKiBVcGRhdGVzIHRoZSB0cmFjayB3aWR0aCB0byBzcGFuIGZyb20gdGhlIGxvdyB0aHVtYiB0byB0aGUgaGlnaCB0aHVtYlxuXHQgKi9cblx0dXBkYXRlVHJhY2tSYW5nZVdpZHRoKCkge1xuXHRcdGNvbnN0IGZyYWN0aW9uID0gdGhpcy5nZXRGcmFjdGlvbkNvbXBsZXRlKHRoaXMuX3ZhbHVlWzBdKTtcblx0XHRjb25zdCBmcmFjdGlvbjIgPSB0aGlzLmdldEZyYWN0aW9uQ29tcGxldGUodGhpcy5fdmFsdWVbMV0pO1xuXHRcdHRoaXMuZmlsbGVkVHJhY2submF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZnJhY3Rpb24gKiAxMDB9JSwgLTUwJSkgJHt0aGlzLnNjYWxlWChmcmFjdGlvbjIgLSBmcmFjdGlvbil9YDtcblx0fVxuXG5cdC8qKiBDaGFuZ2UgaGFuZGxlciBmb3IgdGhlIG9wdGlvbmFsIGlucHV0ICovXG5cdG9uQ2hhbmdlKGV2ZW50LCBpbmRleCkge1xuXHRcdHRoaXMuX3ZhbHVlW2luZGV4XSA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LyoqIEhhbmRsZXMgY2xpY2tzIG9uIHRoZSByYW5nZSB0cmFjaywgYW5kIHNldHRpbmcgdGhlIHZhbHVlIHRvIGl0J3MgXCJyZWFsXCIgZXF1aXZhbGVudCAqL1xuXHRvbkNsaWNrKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XG5cdFx0Y29uc3QgdHJhY2tMZWZ0ID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0dGhpcy5fdmFsdWVbMF0gPSB0aGlzLmNvbnZlcnRUb1ZhbHVlKGV2ZW50LmNsaWVudFggLSB0cmFja0xlZnQpO1xuXHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHR9XG5cblx0LyoqIEZvY3VzIGhhbmRsZXIgZm9yIHRoZSBvcHRpb25hbCBpbnB1dCAqL1xuXHRvbkZvY3VzKHt0YXJnZXR9KSB7XG5cdFx0dGFyZ2V0LnNlbGVjdCgpO1xuXHR9XG5cblx0LyoqIE1vdXNlIG1vdmUgaGFuZGxlci4gUmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIHRoZSB2YWx1ZSBhbmQgdmlzdWFsIHNlbGVjdGlvbiBiYXNlZCBvbiBtb3VzZSBtb3ZlbWVudCAqL1xuXHRvbk1vdXNlTW92ZShldmVudCkge1xuXHRcdGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmlzTW91c2VEb3duKSB7IHJldHVybjsgfVxuXHRcdGNvbnN0IHRyYWNrID0gdGhpcy50cmFjay5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG5cdFx0bGV0IHZhbHVlO1xuXG5cdFx0aWYgKFxuXHRcdFx0ZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPD0gdHJhY2sud2lkdGhcblx0XHRcdCYmIGV2ZW50LmNsaWVudFggLSB0cmFjay5sZWZ0ID49IDBcblx0XHQpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5jb252ZXJ0VG9WYWx1ZShldmVudC5jbGllbnRYIC0gdHJhY2subGVmdCk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIG1vdXNlIGlzIGJleW9uZCB0aGUgbWF4LCBzZXQgdGhlIHZhbHVlIHRvIGBtYXhgXG5cdFx0aWYgKGV2ZW50LmNsaWVudFggLSB0cmFjay5sZWZ0ID4gdHJhY2sud2lkdGgpIHtcblx0XHRcdHZhbHVlID0gdGhpcy5tYXg7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgdGhlIG1vdXNlIGlzIGJlbG93IHRoZSBtaW4sIHNldCB0aGUgdmFsdWUgdG8gYG1pbmBcblx0XHRpZiAoZXZlbnQuY2xpZW50WCAtIHRyYWNrLmxlZnQgPCAwKSB7XG5cdFx0XHR2YWx1ZSA9IHRoaXMubWluO1xuXHRcdH1cblxuXHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl92YWx1ZVt0aGlzLl9mb2N1c2VkVGh1bWJJbmRleF0gPSB2YWx1ZTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIHRoZSBgb25Nb3VzZU1vdmVgIGhhbmRsZXJcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSB0aHVtYiBJZiB0cnVlIHRoZW4gYHRodW1iYCBpcyBjbGlja2VkIGRvd24sIG90aGVyd2lzZSBgdGh1bWIyYCBpcyBjbGlja2VkIGRvd24uXG5cdCAqL1xuXHRvbk1vdXNlRG93bihldmVudCwgaW5kZXggPSAwKSB7XG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblx0XHR0aGlzLl9mb2N1c2VkVGh1bWJJbmRleCA9IGluZGV4O1xuXHRcdHRoaXMudGh1bWJzLnRvQXJyYXkoKVtpbmRleF0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdHRoaXMuaXNNb3VzZURvd24gPSB0cnVlO1xuXHR9XG5cblx0LyoqIERpc2FibGVzIHRoZSBgb25Nb3VzZU1vdmVgIGhhbmRsZXIgKi9cblx0b25Nb3VzZVVwKCkge1xuXHRcdHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDYWxscyBgaW5jcmVtZW50VmFsdWVgIGZvciBBcnJvd1JpZ2h0IGFuZCBBcnJvd1VwLCBgZGVjcmVtZW50VmFsdWVgIGZvciBBcnJvd0xlZnQgYW5kIEFycm93RG93bi5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSB0aHVtYiBJZiB0cnVlIHRoZW4gYHRodW1iYCBpcyBwcmVzc2VkIGRvd24sIG90aGVyd2lzZSBgdGh1bWIyYCBpcyBwcmVzc2VkIGRvd24uXG5cdCAqL1xuXHRvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGluZGV4ID0gMCkge1xuXHRcdGlmICh0aGlzLmRpc2FibGVBcnJvd0tleXMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y29uc3QgbXVsdGlwbGllciA9IGV2ZW50LnNoaWZ0S2V5ID8gdGhpcy5zaGlmdE11bHRpcGxpZXIgOiAxO1xuXHRcdGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dMZWZ0XCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSB7XG5cdFx0XHR0aGlzLmRlY3JlbWVudFZhbHVlKG11bHRpcGxpZXIsIGluZGV4KTtcblx0XHRcdHRoaXMudGh1bWJzLnRvQXJyYXkoKVtpbmRleF0ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuXHRcdFx0dGhpcy5pbmNyZW1lbnRWYWx1ZShtdWx0aXBsaWVyLCBpbmRleCk7XG5cdFx0XHR0aGlzLnRodW1icy50b0FycmF5KClbaW5kZXhdLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIGlzVGVtcGxhdGUodmFsdWUpIHtcblx0XHRyZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcblx0fVxuXG5cdC8qKiBHZXQgb3B0aW9uYWwgaW5wdXQgZmllbGRzICovXG5cdHByb3RlY3RlZCBnZXRJbnB1dHMoKTogSFRNTElucHV0RWxlbWVudFtdIHtcblx0XHRyZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0Om5vdChbdHlwZT1yYW5nZV0pXCIpO1xuXHR9XG59XG4iXX0=